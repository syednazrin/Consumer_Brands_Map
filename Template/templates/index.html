<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Store Locations Map</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #fafafa;
            color: #333;
        }

        .container {
            position: relative;
            height: 100vh;
        }

        #map {
            width: 100%;
            height: 100vh;
        }

        .sidebar {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 400px;
            height: calc(100vh - 40px);
            background: white;
            border: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            transition: width 0.1s ease, opacity 0.3s ease;
        }

        .sidebar-resize-handle {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 1001;
            background: transparent;
            transition: background 0.2s;
        }

        .sidebar-resize-handle:hover {
            background: rgba(255, 0, 0, 0.2);
        }

        .sidebar-resize-handle.dragging {
            background: rgba(255, 0, 0, 0.4);
        }

        .sidebar.collapsed .sidebar-resize-handle {
            display: none;
        }

        .sidebar.collapsed {
            width: 60px;
            height: 60px;
            min-height: 60px;
            max-height: 60px;
        }

        .sidebar.collapsed .sidebar-header > div:first-child > h1,
        .sidebar.collapsed .sidebar-header > div:nth-child(2),
        .sidebar.collapsed .sidebar-header > .stats-summary,
        .sidebar.collapsed .tabs,
        .sidebar.collapsed .tab-content {
            display: none;
        }

        .sidebar.collapsed .sidebar-header {
            padding: 24px 12px;
            text-align: center;
        }

        .sidebar.collapsed .sidebar-header > div:first-child {
            justify-content: center;
            margin-bottom: 0;
        }
        
        .sidebar.collapsed .sidebar-header > div:first-child > div {
            display: none;
        }
        
        .sidebar.collapsed #header-collapse-btn {
            display: flex !important;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin: 0;
            z-index: 1002;
        }
        
        .sidebar.collapsed #header-collapse-icon {
            display: block;
        }
        
        .sidebar.collapsed .sidebar-header {
            position: relative;
            min-height: 60px;
        }

        .sidebar-header {
            padding: 24px;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            text-align: center;
        }
        
        .sidebar-header-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, opacity 0.3s ease-in-out, margin 0.3s ease-in-out, padding 0.3s ease-in-out;
            opacity: 1;
        }
        
        .sidebar-header.collapsed .sidebar-header-content {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
            margin-bottom: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .sidebar-header.collapsed .sidebar-header-content > * {
            display: none;
        }
        
        .sidebar-header-toggle {
            background: #e0e0e0;
            border: 1px solid #ccc;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            padding: 4px 10px;
            border-radius: 4px;
            min-width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            user-select: none;
        }
        
        .sidebar-header-toggle:hover {
            background: #d0d0d0;
        }

        .sidebar-header h1 {
            font-size: 1.4em;
            font-weight: 600;
            color: #ff0000;
            margin-bottom: 16px;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-card {
            background: #f8f8f8;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }

        .stat-number {
            font-size: 1.8em;
            font-weight: 700;
            color: #ff0000;
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-top: 4px;
        }

        .tabs {
            display: flex;
            background: #f8f8f8;
            border-bottom: 1px solid #e0e0e0;
        }

        .tab {
            flex: 1;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            background: transparent;
            border: none;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            transition: all 0.2s ease;
        }

        .tab.active {
            background: white;
            color: #ff0000;
            border-bottom: 2px solid #ff0000;
        }

        .tab:hover {
            background: #f0f0f0;
            color: #ff0000;
        }

        .tab-content {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            background: white;
        }

        .tab-panel {
            display: none;
            flex-direction: column;
        }

        .tab-panel.active {
            display: flex;
        }

        .analytics-header {
            flex-shrink: 0;
        }

        #analytics-content {
            overflow-y: auto;
            flex: 1;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-bottom: 24px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            background: #fafafa;
        }

        .location-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .location-item {
            padding: 16px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .location-item:hover {
            background-color: #f8f8f8;
        }

        .location-item.selected {
            background-color: #fff0f0;
            border-left: 3px solid #ff0000;
        }

        .location-name {
            font-weight: 600;
            color: #ff0000;
            margin-bottom: 6px;
            font-size: 14px;
        }

        .location-address {
            color: #666;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .location-city {
            color: #999;
            font-size: 12px;
        }

        .mapboxgl-popup-content {
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .popup-title {
            font-weight: 600;
            color: #ff0000;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .popup-info {
            color: #666;
            font-size: 13px;
            line-height: 1.4;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #999;
            font-size: 14px;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 14px;
        }

        .floating-legend {
            position: absolute;
            top: 20px;
            left: 20px; /* Top left corner of map */
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            max-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            font-size: 12px;
        }

        .floating-legend-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .floating-legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            padding: 4px 0;
        }

        .floating-legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1.5px solid #fff;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .floating-legend-name {
            flex: 1;
            color: #333;
        }

        .color-scale-bar {
            position: absolute;
            bottom: 30px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 200px;
        }

        .color-scale-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .color-scale-gradient {
            height: 20px;
            width: 100%;
            border-radius: 4px;
            margin-bottom: 8px;
            background: linear-gradient(to right, #90EE90, #FFD700, #FF8C00, #FF4500, #8B0000);
        }

        .color-scale-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #666;
        }

        .industry-selector-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 8px 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .industry-button {
            padding: 8px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            color: #666;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .industry-button:hover {
            background: #f5f5f5;
            border-color: #ff0000;
        }

        .industry-button.active {
            background: #ff0000;
            color: white;
            border-color: #ff0000;
        }

        .floating-legend {
            position: absolute;
            top: 20px;
            left: 20px; /* Top left corner of map */
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            max-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                top: 10px;
                right: 10px;
                left: 10px;
                width: auto;
                height: 50vh;
                border-radius: 15px;
            }
            
            #map {
                height: 100vh;
            }

            .floating-legend {
                left: 10px;
                top: 10px;
                max-width: 200px;
            }

            .color-scale-bar {
                bottom: 10px;
                left: 10px;
                min-width: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="map"></div>
        <div id="floating-legend" class="floating-legend" style="display: block;">
            <div class="floating-legend-title">Visible Companies</div>
            <div id="floating-legend-items"></div>
        </div>
        <div id="color-scale-bar" class="color-scale-bar">
            <div class="color-scale-title" id="color-scale-title">Population (k)</div>
            <div class="color-scale-gradient" id="color-scale-gradient"></div>
            <div class="color-scale-labels">
                <span id="color-scale-min">0</span>
                <span id="color-scale-max">0</span>
            </div>
        </div>
        <div class="sidebar" id="sidebar">
            <div class="sidebar-resize-handle" id="sidebar-resize-handle"></div>
            <div class="sidebar-header" id="sidebar-header">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h1 style="margin: 0; cursor: pointer;" onclick="toggleHeaderCollapse()" title="Click to collapse/expand">Store Locations Map</h1>
                    <button id="header-collapse-btn" type="button" onclick="toggleHeaderCollapse()" class="sidebar-header-toggle" title="Collapse/Expand">
                        <span id="header-collapse-icon">▼</span>
                    </button>
                </div>
                <div class="sidebar-header-content" id="sidebar-header-content">
                <div style="margin-top: 10px; margin-bottom: 10px; text-align: left; font-size: 12px;">
                    <div style="margin-bottom: 8px;">
                        <label for="metric-select" style="font-weight: 500; margin-right: 4px;">District metric:</label>
                        <select id="metric-select" style="padding: 4px 8px; font-size: 12px;">
                            <option value="population_k">Population (k)</option>
                            <option value="income_pc">Income per capita</option>
                            <option value="income_total">Income</option>
                            <option value="market_power_index">Market Power Index</option>
                        </select>
                        <div style="margin-top: 4px; color: #777; font-size: 11px;">
                            Colors on the map show district values for the selected metric.
                        </div>
                        <div id="metric-explanation" style="margin-top: 8px; padding: 8px; background: #f0f8ff; border-radius: 4px; font-size: 11px; color: #0066cc; display: none; border-left: 3px solid #0066cc;">
                            <strong>Market Power Index:</strong> Shows purchasing power per store. Higher values indicate potentially underserved markets with expansion opportunities.
                        </div>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label for="data-select" style="font-weight: 500; margin-right: 4px;">Show data:</label>
                        <select id="data-select" style="padding: 4px 8px; font-size: 12px; width: 100%;">
                            <option value="">Loading categories...</option>
                        </select>
                        <div style="margin-top: 4px; color: #777; font-size: 11px;">
                            Select which category to display on the map.
                        </div>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="cursor: pointer;">
                            <input type="checkbox" id="markers-toggle" checked data-toggle-type="markers" style="margin-right: 4px;">
                            Show store markers
                        </label>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="cursor: pointer;">
                            <input type="checkbox" id="cluster-toggle" checked data-toggle-type="clusters" style="margin-right: 4px;">
                            Cluster store points
                        </label>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="cursor: pointer;">
                            <input type="checkbox" id="dc-toggle" checked style="margin-right: 4px;">
                            Show distribution centers
                        </label>
                    </div>
                    
                    <!-- Distribution Center Statistics -->
                    <div id="dc-statistics" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd; display: none;">
                        <div id="dc-stats-header" style="font-weight: 500; margin-bottom: 4px; cursor: pointer; font-size: 12px;" onclick="toggleDCStats()">
                            Distribution Center Reach ▼
                        </div>
                        <div id="dc-stats-content" style="font-size: 11px; color: #666; max-height: 200px; overflow-y: auto;">
                            <!-- Stats will be populated here -->
                        </div>
                    </div>
                </div>
                <div class="stats-summary">
                    <div class="stat-card">
                        <div class="stat-number" id="total-locations">-</div>
                        <div class="stat-label">Total Stores</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="total-cities">-</div>
                        <div class="stat-label">Districts</div>
                    </div>
                </div>
                </div>
            </div>
            
            <div class="tabs">
                <button class="tab active" data-tab="overview">Overview</button>
                <button class="tab" data-tab="locations">Stores</button>
                <button class="tab" data-tab="analytics">Analytics</button>
                <button class="tab" data-tab="mpi">Market Power Index</button>
            </div>
            
            <div class="tab-content">
                <div class="tab-panel active" id="overview">
                    <div class="loading">Loading overview data...</div>
                </div>
                
                <div class="tab-panel" id="locations">
                    <div class="loading">Loading stores...</div>
                </div>
                
                <div class="tab-panel" id="analytics">
                    <div id="analytics-content" style="overflow-y: auto; flex: 1;">
                        <div class="loading">Loading analytics...</div>
                    </div>
                </div>
                
                <div class="tab-panel" id="mpi">
                    <div class="loading">Loading Market Power Index data...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Mapbox
        mapboxgl.accessToken = 'pk.eyJ1IjoibXNoYW1pIiwiYSI6ImNtMGljY28zMzBqZGsycXF4MGppdmE0bWUifQ.nWArfpCw78mToZi2cN-e8w';
        
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/light-v11',
            center: [101.6869, 3.1390], // Malaysia center
            zoom: 6
        });

        let locationsData = [];
        let visibleLocations = [];
        let convenienceStoreLocations = [];
        let goldShopLocations = [];
        let departmentStoreLocations = [];
        let fastFashionLocations = [];
        let markers = [];
        let districtStats = [];
        let districtGeojson = null;
        let districtsLoaded = false;
        let currentMetric = 'population_k';
        let brandColors = {};
        let currentIndustry = 'Gold Shops';
        let categories = [];

        // Tab functionality
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and panels
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding panel
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
                
                // Load content for the active tab
                loadTabContent(tabId);
            });
        });

        // Distance calculation function (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // DBSCAN Clustering Algorithm
        function dbscan(points, eps, minPts) {
            const clusters = [];
            const visited = new Set();
            const noise = new Set();
            const pointIndex = points.map((_, i) => i);
            
            function getNeighbors(pointIndex, points, eps) {
                const neighbors = [];
                const [lon1, lat1] = points[pointIndex].geometry.coordinates;
                
                for (let i = 0; i < points.length; i++) {
                    if (i === pointIndex) continue;
                    const [lon2, lat2] = points[i].geometry.coordinates;
                    const distance = calculateDistance(lat1, lon1, lat2, lon2);
                    if (distance <= eps) {
                        neighbors.push(i);
                    }
                }
                return neighbors;
            }
            
            function expandCluster(pointIndex, neighbors, clusterId, points, eps, minPts) {
                clusters[clusterId] = [pointIndex];
                
                for (let i = 0; i < neighbors.length; i++) {
                    const neighborIndex = neighbors[i];
                    
                    if (!visited.has(neighborIndex)) {
                        visited.add(neighborIndex);
                        const neighborNeighbors = getNeighbors(neighborIndex, points, eps);
                        if (neighborNeighbors.length >= minPts) {
                            neighbors = neighbors.concat(neighborNeighbors);
                        }
                    }
                    
                    let inCluster = false;
                    for (let c = 0; c < clusters.length; c++) {
                        if (clusters[c].includes(neighborIndex)) {
                            inCluster = true;
                            break;
                        }
                    }
                    
                    if (!inCluster && !noise.has(neighborIndex)) {
                        clusters[clusterId].push(neighborIndex);
                    }
                }
            }
            
            for (let i = 0; i < points.length; i++) {
                if (visited.has(i)) continue;
                visited.add(i);
                
                const neighbors = getNeighbors(i, points, eps);
                if (neighbors.length < minPts) {
                    noise.add(i);
                } else {
                    expandCluster(i, neighbors, clusters.length, points, eps, minPts);
                }
            }
            
            return {
                clusters: clusters.filter(c => c.length > 0),
                noise: Array.from(noise)
            };
        }

        // Function to calculate average distance between stores of same brand
        function calculateBrandDistances(dataToAnalyze) {
            const brandStats = {};
            
            dataToAnalyze.forEach(store => {
                const brand = store.properties.brand || 'Unknown';
                if (!brandStats[brand]) {
                    brandStats[brand] = {
                        stores: [],
                        distances: [],
                        stateStats: {}
                    };
                }
                brandStats[brand].stores.push(store);
            });
            
            // Calculate distances for each brand
            Object.keys(brandStats).forEach(brand => {
                const stores = brandStats[brand].stores;
                const distances = [];
                const stateDistances = {};
                
                stores.forEach((store, i) => {
                    const state = store.properties.state || 'Unknown';
                    if (!stateDistances[state]) {
                        stateDistances[state] = [];
                    }
                    
                    stores.forEach((otherStore, j) => {
                        if (i >= j) return; // Avoid duplicate calculations
                        
                        const [lon1, lat1] = store.geometry.coordinates;
                        const [lon2, lat2] = otherStore.geometry.coordinates;
                        const distance = calculateDistance(lat1, lon1, lat2, lon2);
                        
                        distances.push(distance);
                        
                        const otherState = otherStore.properties.state || 'Unknown';
                        if (state === otherState) {
                            stateDistances[state].push(distance);
                        }
                    });
                });
                
                brandStats[brand].distances = distances;
                brandStats[brand].avgDistance = distances.length > 0
                    ? distances.reduce((a, b) => a + b, 0) / distances.length
                    : 0;
                
                // Calculate state-specific averages
                brandStats[brand].stateStats = {};
                Object.keys(stateDistances).forEach(state => {
                    const stateDists = stateDistances[state];
                    if (stateDists.length > 0) {
                        brandStats[brand].stateStats[state] = {
                            avgDistance: stateDists.reduce((a, b) => a + b, 0) / stateDists.length,
                            storeCount: stores.filter(s => s.properties.state === state).length
                        };
                    }
                });
            });
            
            return brandStats;
        }

        // ========== MAPBOX REVERSE GEOCODING FOR KL SUB-DISTRICTS ==========
        
        // Helper function to format location display with sub-district
        function formatLocationDisplay(props) {
            if (props.sub_district) {
                return `<div><strong>${props.sub_district}</strong>, ${props.state}</div>${props.original_city && props.original_city !== props.sub_district ? `<div style="font-size:11px;color:#999;margin-top:2px;">${props.original_city}</div>` : ''}`;
            }
            return `<div><strong>${props.city}, ${props.state}</strong></div>`;
        }
        // Enrich store location using Mapbox Reverse Geocoding
        async function enrichStoreLocation(store, mapboxToken) {
            const [lon, lat] = store.geometry.coordinates;
            
            try {
                const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${lon},${lat}.json`;
                const params = new URLSearchParams({
                    access_token: mapboxToken,
                    types: 'district,locality,neighborhood,place',
                    country: 'MY',
                    limit: 1
                });
                
                const response = await fetch(`${url}?${params}`);
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.features && data.features.length > 0) {
                    const feature = data.features[0];
                    const context = feature.context || [];
                    
                    // Extract sub-district information
                    let subDistrict = null;
                    let locality = null;
                    let neighborhood = null;
                    
                    // Check main feature text (often contains sub-district for KL)
                    const featureText = feature.text || '';
                    const placeName = feature.place_name || '';
                    
                    // For KL, try to extract sub-district from context or feature text
                    if (placeName.includes('Kuala Lumpur')) {
                        // Check if feature text is not just "Kuala Lumpur"
                        if (featureText && featureText !== 'Kuala Lumpur' && !featureText.includes('Malaysia')) {
                            subDistrict = featureText;
                        }
                        
                        // Check context for district, locality, neighborhood
                        context.forEach(item => {
                            const id = item.id || '';
                            const text = item.text || '';
                            
                            if (id.includes('district') && text !== 'Kuala Lumpur') {
                                subDistrict = text;
                            } else if (id.includes('locality')) {
                                locality = text;
                            } else if (id.includes('neighborhood') && !subDistrict) {
                                neighborhood = text;
                                if (!subDistrict) subDistrict = text;
                            }
                        });
                        
                        // If still no sub-district, try extracting from place_name
                        if (!subDistrict && placeName) {
                            const parts = placeName.split(',');
                            if (parts.length > 1 && parts[0].trim() !== 'Kuala Lumpur') {
                                subDistrict = parts[0].trim();
                            }
                        }
                    }
                    
                    // Update store properties
                    store.properties.original_city = store.properties.city;
                    store.properties.sub_district = subDistrict;
                    store.properties.locality = locality || store.properties.state;
                    store.properties.neighborhood = neighborhood;
                    store.properties.detailed_address = placeName || store.properties.address;
                    
                    // Use sub-district as city for display if available
                    if (subDistrict) {
                        store.properties.city = subDistrict;
                    }
                    
                    return store;
                }
            } catch (error) {
                console.error('Error enriching store location:', error, store.properties);
                // Return store unchanged on error
            }
            
            return store;
        }
        
        // Batch enrichment function for KL stores
        // DISABLED - Will work on it later
        /*
        async function enrichKualaLumpurStores() {
            // Load cache first
            loadLocationCache();
            
            // Filter KL stores
            const klStores = locationsData.filter(store => {
                const state = (store.properties.state || '').toLowerCase();
                const city = (store.properties.city || '').toLowerCase();
                return state.includes('kuala lumpur') || 
                       state.includes('w.p. kuala lumpur') ||
                       state.includes('wp kuala lumpur') ||
                       city.includes('kuala lumpur');
            });
            
            if (klStores.length === 0) {
                console.log('No KL stores found to enrich');
                return;
            }
            
            console.log(`Enriching ${klStores.length} KL stores with detailed location data...`);
            
            // Show progress indicator
            const progressDiv = document.createElement('div');
            progressDiv.id = 'enrichment-progress';
            progressDiv.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #ff0000; color: white; padding: 12px 24px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); font-weight: 600;';
            progressDiv.textContent = `Enriching ${klStores.length} KL store locations...`;
            document.body.appendChild(progressDiv);
            
            const mapboxToken = 'pk.eyJ1IjoibXNoYW1pIiwiYSI6ImNtMGljY28zMzBqZGsycXF4MGppdmE0bWUifQ.nWArfpCw78mToZi2cN-e8w';
            const batchSize = 10;
            let enrichedCount = 0;
            let cachedCount = 0;
            let errorCount = 0;
            
            // Process in batches
            for (let i = 0; i < klStores.length; i += batchSize) {
                const batch = klStores.slice(i, i + batchSize);
                
                // Update progress
                progressDiv.textContent = `Enriching KL stores: ${i + 1}-${Math.min(i + batchSize, klStores.length)} of ${klStores.length}...`;
                
                // Process batch
                const results = await Promise.allSettled(
                    batch.map(store => {
                        const [lon, lat] = store.geometry.coordinates;
                        const cached = getCachedLocationData(lon, lat);
                        if (cached) {
                            cachedCount++;
                            // Apply cached data
                            store.properties.original_city = store.properties.city;
                            store.properties.sub_district = cached.sub_district;
                            store.properties.locality = cached.locality;
                            store.properties.neighborhood = cached.neighborhood;
                            store.properties.detailed_address = cached.detailed_address;
                            if (cached.sub_district) {
                                store.properties.city = cached.sub_district;
                            }
                            return Promise.resolve(store);
                        } else {
                            enrichedCount++;
                            return enrichStoreLocation(store, mapboxToken);
                        }
                    })
                );
                
                // Count errors
                results.forEach(result => {
                    if (result.status === 'rejected') {
                        errorCount++;
                    }
                });
                
                // Delay between batches to respect rate limits
                if (i + batchSize < klStores.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            // Update visible locations if filtered
            if (visibleLocations && visibleLocations.length > 0) {
                // Re-filter to update visible locations with enriched data
                applyIndustryFilter();
            }
            
            // Remove progress indicator
            setTimeout(() => {
                progressDiv.remove();
                
                // Show success message
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #4CAF50; color: white; padding: 12px 24px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); font-weight: 600;';
                successMsg.textContent = `✓ ${enrichedCount} stores enriched, ${cachedCount} from cache${errorCount > 0 ? `, ${errorCount} errors` : ''}`;
                document.body.appendChild(successMsg);
                
                setTimeout(() => successMsg.remove(), 3000);
            }, 500);
            
            console.log(`KL store enrichment complete: ${enrichedCount} enriched, ${cachedCount} from cache, ${errorCount} errors`);
            
            // Refresh displays
            if (document.getElementById('overview').classList.contains('active')) {
                loadOverview(document.getElementById('overview'));
            }
            if (document.getElementById('analytics').classList.contains('active')) {
                loadAnalytics(document.getElementById('analytics'));
            }
        }
        */

        // Load data and initialize map
        async function loadData() {
            try {
                // Load brand colors
                try {
                    const colorsResponse = await fetch('/api/brand-colors');
                    brandColors = await colorsResponse.json();
                } catch (error) {
                    console.error('Error loading brand colors:', error);
                }
                
                // Load categories (dropdown is now in analytics panel)
                try {
                    const categoriesResponse = await fetch('/api/categories');
                    categories = await categoriesResponse.json();
                    // Set initial industry from first category if available
                    if (categories.length > 0) {
                        currentIndustry = categories[0].category;
                    }
                } catch (error) {
                    console.error('Error loading categories:', error);
                }
                
                const response = await fetch('/api/data');
                const data = await response.json();
                locationsData = data.features || [];
                
                // Load 99 SpeedMart distribution centers
                try {
                    const distResponse = await fetch('/api/distribution-centers');
                    const distData = await distResponse.json();
                    window.distributionCentersData = distData.features || [];
                    console.log('Loaded', window.distributionCentersData.length, '99 SpeedMart distribution centers');
                } catch (error) {
                    console.error('Error loading 99 SpeedMart distribution centers:', error);
                    window.distributionCentersData = [];
                }
                
                // Load MR DIY distribution centers
                try {
                    const mrDiyDistResponse = await fetch('/api/mrdiy-distribution-centers');
                    const mrDiyDistData = await mrDiyDistResponse.json();
                    window.mrDiyDistributionCentersData = mrDiyDistData.features || [];
                    console.log('Loaded', window.mrDiyDistributionCentersData.length, 'MR DIY distribution centers');
                } catch (error) {
                    console.error('Error loading MR DIY distribution centers:', error);
                    window.mrDiyDistributionCentersData = [];
                }
                
                // Load Oriental Kopi distribution centers
                try {
                    const orientalKopiDistResponse = await fetch('/api/orientalkopi-distribution-centers');
                    const orientalKopiDistData = await orientalKopiDistResponse.json();
                    window.orientalKopiDistributionCentersData = orientalKopiDistData.features || [];
                    console.log('Loaded', window.orientalKopiDistributionCentersData.length, 'Oriental Kopi distribution centers');
                } catch (error) {
                    console.error('Error loading Oriental Kopi distribution centers:', error);
                    window.orientalKopiDistributionCentersData = [];
                }
                
                // Enrich KL stores with sub-district information (async, non-blocking)
                // DISABLED - Will work on it later
                /*
                setTimeout(() => {
                    enrichKualaLumpurStores().catch(error => {
                        console.error('Error enriching KL stores:', error);
                    });
                }, 1000); // Wait 1 second after data load to not block map rendering
                */
                
                console.log('Loaded', locationsData.length, 'total locations');
                // Check what categories are in the data
                const uniqueCategories = [...new Set(locationsData.map(f => f.properties.category).filter(c => c))];
                console.log('Unique categories found:', uniqueCategories);
                
                // Count Fast Fashion stores in all data
                const fastFashionCount = locationsData.filter(f => {
                    const category = (f.properties.category || f.properties.sector || '').trim();
                    return category.toLowerCase().includes('fast') && category.toLowerCase().includes('fashion');
                }).length;
                if (fastFashionCount > 0) {
                    const fastFashionBrands = [...new Set(locationsData
                        .filter(f => {
                            const category = (f.properties.category || f.properties.sector || '').trim();
                            return category.toLowerCase().includes('fast') && category.toLowerCase().includes('fashion');
                        })
                        .map(f => f.properties.brand))];
                    console.log('=== FAST FASHION DATA VERIFICATION ===');
                    console.log('Total Fast Fashion stores in all data:', fastFashionCount);
                    console.log('Fast Fashion brands:', fastFashionBrands);
                }
                
                // Filter to show only selected industry
                applyIndustryFilter();
                
                // Load district stats and build choropleth
                loadDistrictOverlay();
                
                // Load state borders (always visible)
                loadStateBorders();
                
                // Calculate Market Power Index after both data are loaded
                setTimeout(() => {
                    calculateMarketPowerIndex();
                }, 1000);
                
                // Load initial tab content
                loadTabContent('overview');
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.querySelector('.tab-content').innerHTML = '<div class="error">Error loading data</div>';
            }
        }

        function addStoreLayers(sourcePrefix, hasData, layerPrefix = null) {
            const prefix = layerPrefix || sourcePrefix;
            const sourceName = sourcePrefix;
            
            console.log(`addStoreLayers: prefix=${prefix}, sourceName=${sourceName}, hasData=${hasData}`);
            
            // Don't return early - we need to create layers even if no data initially
            // They'll be hidden if no data, but created so they can show data when it arrives

            // Show/hide layers based on data
            if (hasData) {
                if (map.getLayer(`${prefix}-clusters`)) {
                    map.setLayoutProperty(`${prefix}-clusters`, 'visibility', 'visible');
                }
                if (map.getLayer(`${prefix}-cluster-count`)) {
                    map.setLayoutProperty(`${prefix}-cluster-count`, 'visibility', 'visible');
                }
                if (map.getLayer(`${prefix}-points`)) {
                    map.setLayoutProperty(`${prefix}-points`, 'visibility', 'visible');
                }
            } else {
                // Hide layers if no data (but they still need to be created below)
                if (map.getLayer(`${prefix}-clusters`)) {
                    map.setLayoutProperty(`${prefix}-clusters`, 'visibility', 'none');
                }
                if (map.getLayer(`${prefix}-cluster-count`)) {
                    map.setLayoutProperty(`${prefix}-cluster-count`, 'visibility', 'none');
                }
                if (map.getLayer(`${prefix}-points`)) {
                    map.setLayoutProperty(`${prefix}-points`, 'visibility', 'none');
                }
            }

            // Add cluster circles
            if (!map.getLayer(`${prefix}-clusters`)) {
                map.addLayer({
                    id: `${prefix}-clusters`,
                    type: 'circle',
                    source: sourceName,
                    filter: ['has', 'point_count'],
                    paint: {
                        'circle-opacity': 1.0,
                        'circle-color': [
                            'step',
                            ['get', 'point_count'],
                            '#ff9999',
                            10,
                            '#ff6666',
                            30,
                            '#ff3333',
                            50,
                            '#ff0000'
                        ],
                        'circle-radius': [
                            'step',
                            ['get', 'point_count'],
                            12,
                            10,
                            18,
                            30,
                            24,
                            50,
                            30
                        ],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#fff',
                        'circle-stroke-opacity': 1.0
                    }
                });
            }

            // Add cluster count labels
            if (!map.getLayer(`${prefix}-cluster-count`)) {
                console.log(`Creating ${prefix}-cluster-count layer`);
                map.addLayer({
                    id: `${prefix}-cluster-count`,
                    type: 'symbol',
                    source: sourceName,
                    filter: ['has', 'point_count'],
                    layout: {
                        'text-field': '{point_count_abbreviated}',
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': 12
                    },
                    paint: {
                        'text-color': '#ffffff'
                    }
                });
            }

            // Add unclustered point markers
            if (!map.getLayer(`${prefix}-points`)) {
                console.log(`Creating ${prefix}-points layer`);
                map.addLayer({
                    id: `${prefix}-points`,
                    type: 'circle',
                    source: sourceName,
                    filter: ['!', ['has', 'point_count']],
                    paint: {
                        'circle-radius': 5,
                        'circle-opacity': 1.0,
                        'circle-color': [
                            'coalesce',
                            ['get', 'color'],
                            [
                                'match',
                                ['get', 'brand_key'],
                                'mrdiy', '#FFC82E',
                                'mrtoy', '#E53935',
                                'ecoshop', '#4CAF50',
                                'familymart', '#00BFA5',
                                'mynews', '#D50000',
                                'kkmart', '#FB8C00',
                                'kksupermart', '#FB8C00',
                                'speedmart', '#FF9800',  // Orange
                                'orientalkopi', '#6D4C41',
                                'oldtown', '#8D6E63',
                                'teagarden', '#81C784',
                                'memangmeow', '#9C27B0',
                                'padini', '#000000',
                                'hnm', '#C8102E',
                                'uniqlo', '#E60012',
                                'hla', '#002F6C',
                                'parkson', '#9C27B0',  // Purple
                                'parksonaeon', '#9C27B0',  // Purple
                                'aeon', '#A0008E',
                                'tomei', '#D4AF37',
                                'pohkong', '#C49B3C',
                                'habib', '#B8860B',
                                'wahchan', '#A67C00',
                                '7eleven', '#00A859',
                                '#666666'
                            ]
                        ],
                        'circle-stroke-width': 1.5,
                        'circle-stroke-color': '#ffffff',
                        'circle-stroke-opacity': 1.0
                    }
                });
            }

            // Add click handlers
            map.on('click', `${prefix}-points`, (e) => {
                const coordinates = e.features[0].geometry.coordinates.slice();
                const props = e.features[0].properties;

                new mapboxgl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(`
                        <div class="popup-title">
                            ${props.store_code} - ${props.store_name}
                        </div>
                        <div class="popup-info">
                            <div>${props.address}</div>
                            ${formatLocationDisplay(props)}
                            <div style="margin-top:6px;font-size:12px;color:#999;">
                                ${props.brand || ''}${props.sector ? ` · ${props.sector}` : ''}
                            </div>
                        </div>
                    `)
                    .addTo(map);
            });

            map.on('click', `${prefix}-clusters`, (e) => {
                const features = map.queryRenderedFeatures(e.point, {
                    layers: [`${prefix}-clusters`]
                });
                const clusterId = features[0].properties.cluster_id;
                map.getSource(sourceName).getClusterExpansionZoom(
                    clusterId,
                    (err, zoom) => {
                        if (err) return;
                        map.easeTo({
                            center: features[0].geometry.coordinates,
                            zoom: zoom
                        });
                    }
                );
            });

            // Hover effects
            map.on('mouseenter', `${prefix}-clusters`, () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', `${prefix}-clusters`, () => {
                map.getCanvas().style.cursor = '';
            });
            map.on('mouseenter', `${prefix}-points`, () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', `${prefix}-points`, () => {
                map.getCanvas().style.cursor = '';
            });
        }

        // Calculate connections from stores to nearest distribution center
        function calculateDCConnections() {
            const lineFeatures = [];
            const stats = {};
            
            // Get all 99 SpeedMart stores
            const checkSpeedMart = (feature) => {
                const brandKey = (feature.properties.brand_key || '').toLowerCase();
                const brand = (feature.properties.brand || '').toLowerCase();
                return brandKey.includes('speedmart') || brand.includes('speedmart') || brand.includes('99');
            };
            
            const speedmartStores = (visibleLocations || []).filter(checkSpeedMart);
            
            if (!window.distributionCentersData || window.distributionCentersData.length === 0 || speedmartStores.length === 0) {
                return { lineFeatures: [], stats: {} };
            }
            
            // Initialize stats for each DC
            window.distributionCentersData.forEach(dc => {
                const code = dc.properties.code;
                stats[code] = {
                    code: code,
                    name: dc.properties.name,
                    stores: [],
                    furthestDistance: 0,
                    furthestStoreName: ''
                };
            });
            
            // For each store, find nearest DC and create connection
            speedmartStores.forEach(store => {
                let nearestDC = null;
                let minDistance = Infinity;
                
                const storeLat = store.geometry.coordinates[1];
                const storeLon = store.geometry.coordinates[0];
                
                window.distributionCentersData.forEach(dc => {
                    const dcLat = dc.geometry.coordinates[1];
                    const dcLon = dc.geometry.coordinates[0];
                    const distance = calculateDistance(storeLat, storeLon, dcLat, dcLon);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestDC = dc;
                    }
                });
                
                if (nearestDC) {
                    // Create line feature
                    lineFeatures.push({
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: [
                                store.geometry.coordinates,
                                nearestDC.geometry.coordinates
                            ]
                        },
                        properties: {
                            storeId: store.properties.id,
                            storeName: store.properties.store_name || store.properties.name,
                            dcCode: nearestDC.properties.code,
                            dcName: nearestDC.properties.name,
                            distance: minDistance
                        }
                    });
                    
                    // Update stats
                    const dcCode = nearestDC.properties.code;
                    stats[dcCode].stores.push({
                        id: store.properties.id,
                        name: store.properties.store_name || store.properties.name,
                        distance: minDistance
                    });
                    
                    if (minDistance > stats[dcCode].furthestDistance) {
                        stats[dcCode].furthestDistance = minDistance;
                        stats[dcCode].furthestStoreName = store.properties.store_name || store.properties.name;
                    }
                }
            });
            
            console.log('Calculated', lineFeatures.length, 'DC connections');
            return { lineFeatures, stats };
        }
        
        // Calculate connections from MR DIY + MR TOY stores to nearest MR DIY distribution center
        function calculateMrDiyDCConnections() {
            const lineFeatures = [];
            const stats = {};
            
            // Get all MR DIY and MR TOY stores
            const checkMrDiy = (feature) => {
                const brandKey = (feature.properties.brand_key || '').toLowerCase();
                return brandKey === 'mrdiy' || brandKey === 'mrtoy';
            };
            
            const mrDiyStores = (visibleLocations || []).filter(checkMrDiy);
            
            if (!window.mrDiyDistributionCentersData || window.mrDiyDistributionCentersData.length === 0 || mrDiyStores.length === 0) {
                return { lineFeatures: [], stats: {} };
            }
            
            // Initialize stats for each DC
            window.mrDiyDistributionCentersData.forEach(dc => {
                const code = dc.properties.code;
                stats[code] = {
                    code: code,
                    name: dc.properties.name,
                    stores: [],
                    furthestDistance: 0,
                    furthestStoreName: ''
                };
            });
            
            // For each store, find nearest DC and create connection
            mrDiyStores.forEach(store => {
                let nearestDC = null;
                let minDistance = Infinity;
                
                const storeLat = store.geometry.coordinates[1];
                const storeLon = store.geometry.coordinates[0];
                
                window.mrDiyDistributionCentersData.forEach(dc => {
                    const dcLat = dc.geometry.coordinates[1];
                    const dcLon = dc.geometry.coordinates[0];
                    const distance = calculateDistance(storeLat, storeLon, dcLat, dcLon);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestDC = dc;
                    }
                });
                
                if (nearestDC) {
                    // Create line feature
                    lineFeatures.push({
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: [
                                store.geometry.coordinates,
                                nearestDC.geometry.coordinates
                            ]
                        },
                        properties: {
                            storeId: store.properties.id,
                            storeName: store.properties.store_name || store.properties.name,
                            dcCode: nearestDC.properties.code,
                            dcName: nearestDC.properties.name,
                            distance: minDistance
                        }
                    });
                    
                    // Update stats
                    const dcCode = nearestDC.properties.code;
                    stats[dcCode].stores.push({
                        id: store.properties.id,
                        name: store.properties.store_name || store.properties.name,
                        distance: minDistance
                    });
                    
                    if (minDistance > stats[dcCode].furthestDistance) {
                        stats[dcCode].furthestDistance = minDistance;
                        stats[dcCode].furthestStoreName = store.properties.store_name || store.properties.name;
                    }
                }
            });
            
            console.log('Calculated', lineFeatures.length, 'MR DIY DC connections');
            return { lineFeatures, stats };
        }
        
        // Calculate connections from Oriental Kopi stores to nearest Oriental Kopi distribution center
        function calculateOrientalKopiDCConnections() {
            const lineFeatures = [];
            const stats = {};
            
            // Get all Oriental Kopi stores
            const checkOrientalKopi = (feature) => {
                const brandKey = (feature.properties.brand_key || '').toLowerCase();
                return brandKey === 'orientalkopi';
            };
            
            const orientalKopiStores = (visibleLocations || []).filter(checkOrientalKopi);
            
            if (!window.orientalKopiDistributionCentersData || window.orientalKopiDistributionCentersData.length === 0 || orientalKopiStores.length === 0) {
                return { lineFeatures: [], stats: {} };
            }
            
            // Initialize stats for each DC
            window.orientalKopiDistributionCentersData.forEach(dc => {
                const code = dc.properties.code;
                stats[code] = {
                    code: code,
                    name: dc.properties.name,
                    stores: [],
                    furthestDistance: 0,
                    furthestStoreName: ''
                };
            });
            
            // For each store, find nearest DC and create connection
            orientalKopiStores.forEach(store => {
                let nearestDC = null;
                let minDistance = Infinity;
                
                const storeLat = store.geometry.coordinates[1];
                const storeLon = store.geometry.coordinates[0];
                
                window.orientalKopiDistributionCentersData.forEach(dc => {
                    const dcLat = dc.geometry.coordinates[1];
                    const dcLon = dc.geometry.coordinates[0];
                    const distance = calculateDistance(storeLat, storeLon, dcLat, dcLon);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestDC = dc;
                    }
                });
                
                if (nearestDC) {
                    // Create line feature
                    lineFeatures.push({
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: [
                                store.geometry.coordinates,
                                nearestDC.geometry.coordinates
                            ]
                        },
                        properties: {
                            storeId: store.properties.id,
                            storeName: store.properties.store_name || store.properties.name,
                            dcCode: nearestDC.properties.code,
                            dcName: nearestDC.properties.name,
                            distance: minDistance
                        }
                    });
                    
                    // Update stats
                    const dcCode = nearestDC.properties.code;
                    stats[dcCode].stores.push({
                        id: store.properties.id,
                        name: store.properties.store_name || store.properties.name,
                        distance: minDistance
                    });
                    
                    if (minDistance > stats[dcCode].furthestDistance) {
                        stats[dcCode].furthestDistance = minDistance;
                        stats[dcCode].furthestStoreName = store.properties.store_name || store.properties.name;
                    }
                }
            });
            
            console.log('Calculated', lineFeatures.length, 'Oriental Kopi DC connections');
            return { lineFeatures, stats };
        }
        
        // Update DC statistics panel
        function updateDCStatisticsPanel() {
            const statsContainer = document.getElementById('dc-stats-content');
            if (!statsContainer || !window.dcConnectionStats) {
                return;
            }
            
            const dcArray = Object.values(window.dcConnectionStats)
                .filter(dc => dc.stores.length > 0)
                .sort((a, b) => b.furthestDistance - a.furthestDistance);
            
            if (dcArray.length === 0) {
                statsContainer.innerHTML = '<div style="padding: 4px 0; color: #999;">No connections available</div>';
                return;
            }
            
            statsContainer.innerHTML = dcArray.map(dc => `
                <div style="padding: 4px 0; border-bottom: 1px solid #eee;">
                    <div style="font-weight: 500;">${dc.code} - ${dc.name}</div>
                    <div style="color: #999; font-size: 10px;">
                        Furthest: ${dc.furthestDistance.toFixed(1)} km (${dc.stores.length} stores)
                    </div>
                </div>
            `).join('');
        }
        
        // Toggle DC statistics panel
        function toggleDCStats() {
            const content = document.getElementById('dc-stats-content');
            const header = document.getElementById('dc-stats-header');
            if (content && header) {
                const isCollapsed = content.style.display === 'none';
                content.style.display = isCollapsed ? 'block' : 'none';
                header.innerHTML = isCollapsed ? 'Distribution Center Reach ▼' : 'Distribution Center Reach ▶';
            }
        }

        function hideAllMarkerLayers() {
            const allMarkerLayers = [
                'speedmart-distribution-centers-layer',
                'mrdiy-distribution-centers-layer',
                'orientalkopi-distribution-centers-layer',
                'speedmart-dc-connections-layer',
                'mrdiy-dc-connections-layer',
                'orientalkopi-dc-connections-layer',
                'convenience-clusters',
                'convenience-cluster-count',
                'convenience-points',
                'convenience-stores-nocluster-layer',
                'goldshops-clusters',
                'goldshops-cluster-count',
                'goldshops-points',
                'goldshops-nocluster-layer',
                'departmentstores-clusters',
                'departmentstores-cluster-count',
                'departmentstores-points',
                'departmentstores-nocluster-layer',
                'fastfashion-clusters',
                'fastfashion-cluster-count',
                'fastfashion-points',
                'fastfashion-nocluster-layer',
                'clusters',
                'cluster-count',
                'unclustered-point',
                'stores-nocluster-layer'
            ];
            
            allMarkerLayers.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.setLayoutProperty(layerId, 'visibility', 'none');
                }
            });
            
            console.log('All marker layers hidden');
        }

        function addMarkersToMap() {
            // If no category is selected, hide all markers and show only choropleth
            if (!currentIndustry || currentIndustry === '') {
                console.log('No category selected - showing choropleth only');
                hideAllMarkerLayers();
                
                // Ensure district layers visible
                if (map.getLayer('district-fills')) {
                    map.setLayoutProperty('district-fills', 'visibility', 'visible');
                }
                if (map.getLayer('district-borders')) {
                    map.setLayoutProperty('district-borders', 'visibility', 'visible');
                }
                if (map.getLayer('state-borders')) {
                    map.setLayoutProperty('state-borders', 'visibility', 'visible');
                }
                
                return; // Exit - no markers
            }
            
            // Clear existing markers (if we ever used DOM markers)
            markers.forEach(marker => marker.remove());
            markers = [];

            // Only use visibleLocations - don't fall back to all locationsData
            const features = visibleLocations || [];
            console.log('Adding markers for', features.length, 'stores from', currentIndustry);

            // Check which industry mode we're in
            const isConvenienceStoresMode = currentIndustry === 'Convenience Stores';
            const isGoldShopsMode = currentIndustry === 'Gold Shops';
            const isDepartmentStoresMode = currentIndustry === 'Department Stores';
            const isFastFashionMode = currentIndustry === 'Fast Fashion';
            
            const convenienceFeatures = isConvenienceStoresMode ? convenienceStoreLocations : [];
            const goldShopFeatures = isGoldShopsMode ? goldShopLocations : [];
            const departmentStoreFeatures = isDepartmentStoresMode ? departmentStoreLocations : [];
            const fastFashionFeatures = isFastFashionMode ? fastFashionLocations : [];

            const convenienceGeojson = {
                type: 'FeatureCollection',
                features: convenienceFeatures
            };
            
            const goldShopsGeojson = {
                type: 'FeatureCollection',
                features: goldShopFeatures
            };

            const geojsonData = {
                type: 'FeatureCollection',
                features: features
            };

            // Hide convenience store layers if NOT in convenience stores mode
            if (!isConvenienceStoresMode) {
                if (map.getLayer('convenience-clusters')) {
                    map.setLayoutProperty('convenience-clusters', 'visibility', 'none');
                }
                if (map.getLayer('convenience-cluster-count')) {
                    map.setLayoutProperty('convenience-cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('convenience-points')) {
                    map.setLayoutProperty('convenience-points', 'visibility', 'none');
                }
                if (map.getLayer('convenience-stores-nocluster-layer')) {
                    map.setLayoutProperty('convenience-stores-nocluster-layer', 'visibility', 'none');
                }
                if (map.getSource('convenience-stores')) {
                    map.getSource('convenience-stores').setData({ type: 'FeatureCollection', features: [] });
                }
                // Hide distribution centers when not in convenience stores mode
                if (map.getLayer('speedmart-distribution-centers-layer')) {
                    map.setLayoutProperty('speedmart-distribution-centers-layer', 'visibility', 'none');
                }
            }
            
            // Hide gold shops layers if NOT in gold shops mode
            if (!isGoldShopsMode) {
                if (map.getLayer('goldshops-clusters')) {
                    map.setLayoutProperty('goldshops-clusters', 'visibility', 'none');
                }
                if (map.getLayer('goldshops-cluster-count')) {
                    map.setLayoutProperty('goldshops-cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('goldshops-points')) {
                    map.setLayoutProperty('goldshops-points', 'visibility', 'none');
                }
                if (map.getLayer('goldshops-nocluster-layer')) {
                    map.setLayoutProperty('goldshops-nocluster-layer', 'visibility', 'none');
                }
                if (map.getSource('goldshops-stores')) {
                    map.getSource('goldshops-stores').setData({ type: 'FeatureCollection', features: [] });
                }
            }
            
            // Hide department stores layers if NOT in department stores mode
            if (!isDepartmentStoresMode) {
                if (map.getLayer('departmentstores-clusters')) {
                    map.setLayoutProperty('departmentstores-clusters', 'visibility', 'none');
                }
                if (map.getLayer('departmentstores-cluster-count')) {
                    map.setLayoutProperty('departmentstores-cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('departmentstores-points')) {
                    map.setLayoutProperty('departmentstores-points', 'visibility', 'none');
                }
                if (map.getLayer('departmentstores-nocluster-layer')) {
                    map.setLayoutProperty('departmentstores-nocluster-layer', 'visibility', 'none');
                }
                if (map.getSource('departmentstores-stores')) {
                    map.getSource('departmentstores-stores').setData({ type: 'FeatureCollection', features: [] });
                }
            }
            
            // Hide fast fashion layers if NOT in fast fashion mode
            if (!isFastFashionMode) {
                if (map.getLayer('fastfashion-clusters')) {
                    map.setLayoutProperty('fastfashion-clusters', 'visibility', 'none');
                }
                if (map.getLayer('fastfashion-cluster-count')) {
                    map.setLayoutProperty('fastfashion-cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('fastfashion-points')) {
                    map.setLayoutProperty('fastfashion-points', 'visibility', 'none');
                }
                if (map.getLayer('fastfashion-nocluster-layer')) {
                    map.setLayoutProperty('fastfashion-nocluster-layer', 'visibility', 'none');
                }
                if (map.getSource('fastfashion-stores')) {
                    map.getSource('fastfashion-stores').setData({ type: 'FeatureCollection', features: [] });
                }
            }

            // Handle convenience stores mode with separate layers
            if (isConvenienceStoresMode) {
                console.log('=== CONVENIENCE STORES MODE ===');
                console.log('Convenience features:', convenienceFeatures.length);
                console.log('Convenience store locations:', convenienceStoreLocations.length);
                console.log('Visible locations:', visibleLocations.length);
                console.log('Convenience GeoJSON features:', convenienceGeojson.features.length);
                
                // Always create/update the source, even if empty
                if (!map.getSource('convenience-stores')) {
                    console.log('Creating convenience-stores source');
                    map.addSource('convenience-stores', {
                        type: 'geojson',
                        data: convenienceGeojson,
                        cluster: true,
                        clusterMaxZoom: 14,
                        clusterRadius: 50
                    });
                } else {
                    console.log('Updating convenience-stores source with', convenienceGeojson.features.length, 'features');
                    map.getSource('convenience-stores').setData(convenienceGeojson);
                }

                // Always add layers - they'll be hidden if no data
                console.log('Adding convenience store layers, hasData:', convenienceFeatures.length > 0);
                addStoreLayers('convenience-stores', convenienceFeatures.length > 0, 'convenience');
                
                // Create non-clustered source for when clustering is disabled
                if (!map.getSource('convenience-stores-nocluster')) {
                    map.addSource('convenience-stores-nocluster', {
                        type: 'geojson',
                        data: convenienceGeojson
                    });
                    
                    map.addLayer({
                        id: 'convenience-stores-nocluster-layer',
                        type: 'circle',
                        source: 'convenience-stores-nocluster',
                        layout: {
                            visibility: 'none' // Hidden by default (clustering enabled)
                        },
                        paint: {
                            'circle-radius': 5,
                            'circle-opacity': 1.0,
                            'circle-color': [
                                'coalesce',
                                ['get', 'color'],
                                [
                                    'match',
                                    ['get', 'brand_key'],
                                    'familymart', '#00BFA5',
                                    'mynews', '#D50000',
                                    'kkmart', '#FB8C00',
                                    'kksupermart', '#FB8C00',
                                    '7eleven', '#00A859',
                                    '#666666'
                                ]
                            ],
                            'circle-stroke-width': 1.5,
                            'circle-stroke-color': '#ffffff',
                            'circle-stroke-opacity': 1.0
                        }
                    });
                    
                    // Add click handler for non-clustered layer
                    map.on('click', 'convenience-stores-nocluster-layer', (e) => {
                        const coordinates = e.features[0].geometry.coordinates.slice();
                        const props = e.features[0].properties;
                        
                        new mapboxgl.Popup()
                            .setLngLat(coordinates)
                            .setHTML(`
                                <div class="popup-title">
                                    ${props.store_code} - ${props.store_name}
                                </div>
                                <div class="popup-info">
                                    <div>${props.address}</div>
                                    ${formatLocationDisplay(props)}
                                    <div style="margin-top:6px;font-size:12px;color:#999;">
                                        ${props.brand || ''}${props.sector ? ` · ${props.sector}` : ''}
                                    </div>
                                </div>
                            `)
                            .addTo(map);
                    });
                    
                    // Hover effects
                    map.on('mouseenter', 'convenience-stores-nocluster-layer', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', 'convenience-stores-nocluster-layer', () => {
                        map.getCanvas().style.cursor = '';
                    });
                } else {
                    // Update existing source
                    map.getSource('convenience-stores-nocluster').setData(convenienceGeojson);
                }
                
                // Force visibility if we have data
                if (convenienceFeatures.length > 0) {
                    console.log('Setting convenience layers to visible');
                    setTimeout(() => {
                        if (map.getLayer('convenience-clusters')) {
                            map.setLayoutProperty('convenience-clusters', 'visibility', 'visible');
                            console.log('convenience-clusters set to visible');
                        }
                        if (map.getLayer('convenience-cluster-count')) {
                            map.setLayoutProperty('convenience-cluster-count', 'visibility', 'visible');
                            console.log('convenience-cluster-count set to visible');
                        }
                        if (map.getLayer('convenience-points')) {
                            map.setLayoutProperty('convenience-points', 'visibility', 'visible');
                            console.log('convenience-points set to visible');
                        }
                    }, 100);
                } else {
                    console.warn('No convenience features to display!');
                }
                
                // Ensure convenience stores are on top of districts
                // In Mapbox, moveLayer(layerId, beforeId) moves layerId to be BEFORE beforeId
                // To put convenience stores ABOVE districts, move districts BEFORE convenience stores
                const reorderLayers = () => {
                    try {
                        // Prioritize cluster layers when they exist (for when clustering is enabled)
                        // Otherwise use points or non-clustered layer
                        let targetConvenienceLayer = null;
                        
                        // Check for cluster layers first (these should be on top when clustering is enabled)
                        if (map.getLayer('convenience-clusters')) {
                            targetConvenienceLayer = 'convenience-clusters';
                        } else if (map.getLayer('convenience-cluster-count')) {
                            targetConvenienceLayer = 'convenience-cluster-count';
                        } else if (map.getLayer('convenience-points')) {
                            targetConvenienceLayer = 'convenience-points';
                        } else if (map.getLayer('convenience-stores-nocluster-layer')) {
                            targetConvenienceLayer = 'convenience-stores-nocluster-layer';
                        }
                        
                        if (targetConvenienceLayer) {
                            // Move districts to be BEFORE convenience stores (which puts districts BELOW)
                            if (map.getLayer('district-borders')) {
                                map.moveLayer('district-borders', targetConvenienceLayer);
                            }
                            if (map.getLayer('district-fills')) {
                                map.moveLayer('district-fills', targetConvenienceLayer);
                            }
                            console.log('Moved districts below convenience stores (target:', targetConvenienceLayer, ')');
                        }
                    } catch (e) {
                        console.warn('Could not reorder convenience store layers:', e);
                    }
                };
                
                // Try multiple times to ensure layers are ready
                setTimeout(reorderLayers, 200);
                setTimeout(reorderLayers, 500);
                setTimeout(reorderLayers, 1000);
                setTimeout(reorderLayers, 1500);

                // Hide old single-layer stores if they exist
                if (map.getLayer('clusters')) {
                    map.setLayoutProperty('clusters', 'visibility', 'none');
                }
                if (map.getLayer('cluster-count')) {
                    map.setLayoutProperty('cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('unclustered-point')) {
                    map.setLayoutProperty('unclustered-point', 'visibility', 'none');
                }
                if (map.getLayer('stores-nocluster-layer')) {
                    map.setLayoutProperty('stores-nocluster-layer', 'visibility', 'none');
                }
                
                // Update non-clustered source data
                if (map.getSource('convenience-stores-nocluster')) {
                    map.getSource('convenience-stores-nocluster').setData(convenienceGeojson);
                }
                
                return;
            }
            
            // Add 99 SpeedMart distribution centers if 99 SpeedMart is visible
            // Check multiple sources for robust detection - runs independently of industry mode
            const checkSpeedMart = (feature) => {
                const brandKey = (feature.properties.brand_key || '').toLowerCase();
                const brand = (feature.properties.brand || '').toLowerCase();
                const category = (feature.properties.category || '').toLowerCase();
                return brandKey === 'speedmart' || 
                       brandKey === '99speedmart' || 
                       brandKey === '99-speedmart' ||
                       brand === '99 speedmart' ||
                       brand === '99speedmart' ||
                       category.includes('99 speedmart') ||
                       category.includes('speedmart');
            };
            
            const hasSpeedMartInConvenience = convenienceFeatures.some(checkSpeedMart);
            const hasSpeedMartInVisible = visibleLocations && visibleLocations.some(checkSpeedMart);
            const hasSpeedMartInCategory = currentIndustry && (
                currentIndustry.toLowerCase().includes('convenience') || 
                currentIndustry.toLowerCase().includes('speedmart')
            );
            
            const hasSpeedMart = hasSpeedMartInConvenience || hasSpeedMartInVisible || hasSpeedMartInCategory;
            
            console.log('99 SpeedMart Detection:', {
                hasSpeedMartInConvenience,
                hasSpeedMartInVisible,
                hasSpeedMartInCategory,
                hasSpeedMart,
                currentIndustry,
                convenienceFeaturesCount: convenienceFeatures.length,
                visibleLocationsCount: visibleLocations ? visibleLocations.length : 0,
                distributionCentersCount: window.distributionCentersData ? window.distributionCentersData.length : 0
            });
            
            // Check if DC toggle is enabled
            const dcToggle = document.getElementById('dc-toggle');
            const showDC = dcToggle ? dcToggle.checked : true; // Default to true if toggle doesn't exist yet
            
            if (hasSpeedMart && showDC && window.distributionCentersData && window.distributionCentersData.length > 0) {
                const distCentersGeoJSON = {
                    type: 'FeatureCollection',
                    features: window.distributionCentersData
                };
                
                // Add or update source
                if (!map.getSource('speedmart-distribution-centers')) {
                    map.addSource('speedmart-distribution-centers', {
                        type: 'geojson',
                        data: distCentersGeoJSON
                    });
                    
                    // Add distribution centers layer with blue color and bigger size (radius 18 - 3.6x normal size)
                    map.addLayer({
                        id: 'speedmart-distribution-centers-layer',
                        type: 'circle',
                        source: 'speedmart-distribution-centers',
                        paint: {
                            'circle-radius': 18,  // Bigger than store markers (5 * 3.6 = 18)
                            'circle-opacity': 1.0,
                            'circle-color': '#2196F3',  // Blue color
                            'circle-stroke-width': 3,
                            'circle-stroke-color': '#ffffff',
                            'circle-stroke-opacity': 1.0
                        }
                    });
                    
                    console.log('Created distribution centers layer with', window.distributionCentersData.length, 'centers');
                    
                    // Calculate connections from stores to nearest DC
                    const dcConnections = calculateDCConnections();
                    
                    // Add connections layer
                    if (dcConnections.lineFeatures.length > 0) {
                        if (!map.getSource('speedmart-dc-connections')) {
                            map.addSource('speedmart-dc-connections', {
                                type: 'geojson',
                                data: {
                                    type: 'FeatureCollection',
                                    features: dcConnections.lineFeatures
                                }
                            });
                            
                            // Add layer for connection lines with transparent blue color
                            map.addLayer({
                                id: 'speedmart-dc-connections-layer',
                                type: 'line',
                                source: 'speedmart-dc-connections',
                                paint: {
                                    'line-color': '#2196F3',
                                    'line-width': 1,
                                    'line-opacity': 0.35  // Semi-transparent (35%)
                                }
                            });
                            
                            console.log('Created DC connections layer with', dcConnections.lineFeatures.length, 'connections');
                        } else {
                            map.getSource('speedmart-dc-connections').setData({
                                type: 'FeatureCollection',
                                features: dcConnections.lineFeatures
                            });
                            
                            // Ensure layer is visible
                            if (map.getLayer('speedmart-dc-connections-layer')) {
                                map.setLayoutProperty('speedmart-dc-connections-layer', 'visibility', 'visible');
                            }
                        }
                        
                        // Store connection stats for display
                        window.dcConnectionStats = dcConnections.stats;
                        updateDCStatisticsPanel();
                        
                        // Show statistics panel
                        const dcStatsPanel = document.getElementById('dc-statistics');
                        if (dcStatsPanel) {
                            dcStatsPanel.style.display = 'block';
                        }
                    }
                    
                    // Add click handler for distribution centers
                    map.on('click', 'speedmart-distribution-centers-layer', (e) => {
                        const coordinates = e.features[0].geometry.coordinates.slice();
                        const props = e.features[0].properties;
                        
                        new mapboxgl.Popup()
                            .setLngLat(coordinates)
                            .setHTML(`
                                <div class="popup-title">
                                    ${props.code || ''} - ${props.name || 'Distribution Center'}
                                </div>
                                <div class="popup-info">
                                    <div><strong>Distribution Center</strong></div>
                                    <div>${props.address || ''}</div>
                                    <div style="margin-top:6px;font-size:12px;color:#999;">
                                        ${props.state || ''}
                                    </div>
                                    ${props.google_maps_url ? `
                                        <div style="margin-top:6px;">
                                            <a href="${props.google_maps_url}" target="_blank" style="color:#2196F3;text-decoration:none;">
                                                View on Google Maps →
                                            </a>
                                        </div>
                                    ` : ''}
                                </div>
                            `)
                            .addTo(map);
                    });
                    
                    // Hover effects
                    map.on('mouseenter', 'speedmart-distribution-centers-layer', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', 'speedmart-distribution-centers-layer', () => {
                        map.getCanvas().style.cursor = '';
                    });
                } else {
                    // Update existing source
                    map.getSource('speedmart-distribution-centers').setData(distCentersGeoJSON);
                    // Force layer to be visible
                    if (map.getLayer('speedmart-distribution-centers-layer')) {
                        map.setLayoutProperty('speedmart-distribution-centers-layer', 'visibility', 'visible');
                        console.log('Distribution centers layer set to visible');
                    } else {
                        console.warn('Distribution centers layer not found, recreating...');
                        // Recreate layer if it doesn't exist
                        map.addLayer({
                            id: 'speedmart-distribution-centers-layer',
                            type: 'circle',
                            source: 'speedmart-distribution-centers',
                            paint: {
                                'circle-radius': 18,
                                'circle-opacity': 1.0,
                                'circle-color': '#2196F3',
                                'circle-stroke-width': 3,
                                'circle-stroke-color': '#ffffff',
                                'circle-stroke-opacity': 1.0
                            }
                        });
                        // Re-add event handlers
                        map.on('click', 'speedmart-distribution-centers-layer', (e) => {
                            const coordinates = e.features[0].geometry.coordinates.slice();
                            const props = e.features[0].properties;
                            new mapboxgl.Popup()
                                .setLngLat(coordinates)
                                .setHTML(`
                                    <div class="popup-title">
                                        ${props.code || ''} - ${props.name || 'Distribution Center'}
                                    </div>
                                    <div class="popup-info">
                                        <div><strong>Distribution Center</strong></div>
                                        <div>${props.address || ''}</div>
                                        <div style="margin-top:6px;font-size:12px;color:#999;">
                                            ${props.state || ''}
                                        </div>
                                        ${props.google_maps_url ? `
                                            <div style="margin-top:6px;">
                                                <a href="${props.google_maps_url}" target="_blank" style="color:#2196F3;text-decoration:none;">
                                                    View on Google Maps →
                                                </a>
                                            </div>
                                        ` : ''}
                                    </div>
                                `)
                                .addTo(map);
                        });
                        map.on('mouseenter', 'speedmart-distribution-centers-layer', () => {
                            map.getCanvas().style.cursor = 'pointer';
                        });
                        map.on('mouseleave', 'speedmart-distribution-centers-layer', () => {
                            map.getCanvas().style.cursor = '';
                        });
                    }
                }
                
                // Ensure distribution centers are at the same level as store markers (above districts)
                // Position DC layer right after store marker layers, not above them
                const reorderDistributionCenters = () => {
                    try {
                        // Find the topmost store marker layer and position DC right after it
                        const storeLayers = [
                            'convenience-clusters',
                            'convenience-cluster-count', 
                            'convenience-points',
                            'convenience-stores-nocluster-layer',
                            'goldshops-clusters',
                            'goldshops-cluster-count',
                            'goldshops-points',
                            'goldshops-nocluster-layer',
                            'departmentstores-clusters',
                            'departmentstores-cluster-count',
                            'departmentstores-points',
                            'departmentstores-nocluster-layer',
                            'fastfashion-clusters',
                            'fastfashion-cluster-count',
                            'fastfashion-points',
                            'fastfashion-nocluster-layer',
                            'clusters',
                            'cluster-count',
                            'unclustered-point',
                            'stores-nocluster-layer'
                        ];
                        
                        // Find the last (topmost) store layer that exists
                        let topStoreLayer = null;
                        for (let i = storeLayers.length - 1; i >= 0; i--) {
                            if (map.getLayer(storeLayers[i])) {
                                topStoreLayer = storeLayers[i];
                                break;
                            }
                        }
                        
                        if (topStoreLayer && map.getLayer('speedmart-distribution-centers-layer')) {
                            // Position DC layer right after the top store layer (same level)
                            map.moveLayer('speedmart-distribution-centers-layer', topStoreLayer);
                            console.log('Positioned distribution centers at same level as store markers (after:', topStoreLayer, ')');
                        }
                        
                        // Position connection lines below DC markers but above districts
                        if (map.getLayer('speedmart-dc-connections-layer') && map.getLayer('speedmart-distribution-centers-layer')) {
                            map.moveLayer('speedmart-dc-connections-layer', 'speedmart-distribution-centers-layer');
                            console.log('Positioned connection lines below DC markers');
                        }
                        
                        // Ensure districts are below both store markers, DC, and connections
                        const bottomLayer = map.getLayer('speedmart-dc-connections-layer') ? 'speedmart-dc-connections-layer' : 'speedmart-distribution-centers-layer';
                        if (bottomLayer && map.getLayer(bottomLayer)) {
                            if (map.getLayer('district-fills')) {
                                map.moveLayer('district-fills', bottomLayer);
                            }
                            if (map.getLayer('district-borders')) {
                                map.moveLayer('district-borders', bottomLayer);
                            }
                        }
                    } catch (e) {
                        console.warn('Could not reorder distribution centers layer:', e);
                    }
                };
                
                // Try multiple times to ensure layers are ready
                setTimeout(reorderDistributionCenters, 200);
                setTimeout(reorderDistributionCenters, 500);
                setTimeout(reorderDistributionCenters, 1000);
                setTimeout(reorderDistributionCenters, 1500);
                
                // Ensure district layers stay at bottom
                setTimeout(ensureDistrictLayersAtBottom, 300);
                setTimeout(ensureDistrictLayersAtBottom, 600);
                setTimeout(ensureDistrictLayersAtBottom, 1100);
                setTimeout(ensureDistrictLayersAtBottom, 1600);
            } else {
                // Hide distribution centers if 99 SpeedMart is not visible or toggle is off
                console.log('Hiding distribution centers - 99 SpeedMart not detected or toggle is off');
                if (map.getLayer('speedmart-distribution-centers-layer')) {
                    map.setLayoutProperty('speedmart-distribution-centers-layer', 'visibility', 'none');
                }
                if (map.getLayer('speedmart-dc-connections-layer')) {
                    map.setLayoutProperty('speedmart-dc-connections-layer', 'visibility', 'none');
                }
                if (map.getSource('speedmart-distribution-centers')) {
                    map.getSource('speedmart-distribution-centers').setData({ type: 'FeatureCollection', features: [] });
                }
                if (map.getSource('speedmart-dc-connections')) {
                    map.getSource('speedmart-dc-connections').setData({ type: 'FeatureCollection', features: [] });
                }
                
                // Hide statistics panel
                const dcStatsPanel = document.getElementById('dc-statistics');
                if (dcStatsPanel) {
                    dcStatsPanel.style.display = 'none';
                }
            }
            
            // Add MR DIY distribution centers if MR DIY or MR TOY stores are visible
            const checkMrDiy = (feature) => {
                const brandKey = (feature.properties.brand_key || '').toLowerCase();
                return brandKey === 'mrdiy' || brandKey === 'mrtoy';
            };
            
            const hasMrDiy = visibleLocations && visibleLocations.some(checkMrDiy);
            
            if (hasMrDiy && showDC && window.mrDiyDistributionCentersData && window.mrDiyDistributionCentersData.length > 0) {
                const mrDiyDistCentersGeoJSON = {
                    type: 'FeatureCollection',
                    features: window.mrDiyDistributionCentersData
                };
                
                if (!map.getSource('mrdiy-distribution-centers')) {
                    map.addSource('mrdiy-distribution-centers', {
                        type: 'geojson',
                        data: mrDiyDistCentersGeoJSON
                    });
                    
                    map.addLayer({
                        id: 'mrdiy-distribution-centers-layer',
                        type: 'circle',
                        source: 'mrdiy-distribution-centers',
                        paint: {
                            'circle-radius': 18,
                            'circle-opacity': 1.0,
                            'circle-color': '#FFC82E',
                            'circle-stroke-width': 3,
                            'circle-stroke-color': '#ffffff',
                            'circle-stroke-opacity': 1.0
                        }
                    });
                    
                    const mrDiyDcConnections = calculateMrDiyDCConnections();
                    
                    if (mrDiyDcConnections.lineFeatures.length > 0) {
                        if (!map.getSource('mrdiy-dc-connections')) {
                            map.addSource('mrdiy-dc-connections', {
                                type: 'geojson',
                                data: {
                                    type: 'FeatureCollection',
                                    features: mrDiyDcConnections.lineFeatures
                                }
                            });
                            
                            map.addLayer({
                                id: 'mrdiy-dc-connections-layer',
                                type: 'line',
                                source: 'mrdiy-dc-connections',
                                paint: {
                                    'line-color': '#FFC82E',
                                    'line-width': 1,
                                    'line-opacity': 0.35
                                }
                            });
                        }
                    }
                    
                    map.on('click', 'mrdiy-distribution-centers-layer', (e) => {
                        const coordinates = e.features[0].geometry.coordinates.slice();
                        const props = e.features[0].properties;
                        
                        new mapboxgl.Popup()
                            .setLngLat(coordinates)
                            .setHTML(`
                                <div class="popup-title">
                                    ${props.code || ''} - ${props.name || 'Distribution Center'}
                                </div>
                                <div class="popup-info">
                                    <div><strong>MR DIY Distribution Center</strong></div>
                                    <div>${props.address || ''}</div>
                                    <div style="margin-top:6px;font-size:12px;color:#999;">
                                        ${props.state || ''}
                                    </div>
                                    ${props.google_maps_url ? `
                                        <div style="margin-top:6px;">
                                            <a href="${props.google_maps_url}" target="_blank" style="color:#FFC82E;text-decoration:none;">
                                                View on Google Maps →
                                            </a>
                                        </div>
                                    ` : ''}
                                </div>
                            `)
                            .addTo(map);
                    });
                    
                    map.on('mouseenter', 'mrdiy-distribution-centers-layer', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', 'mrdiy-distribution-centers-layer', () => {
                        map.getCanvas().style.cursor = '';
                    });
                } else {
                    map.getSource('mrdiy-distribution-centers').setData(mrDiyDistCentersGeoJSON);
                    if (map.getLayer('mrdiy-distribution-centers-layer')) {
                        map.setLayoutProperty('mrdiy-distribution-centers-layer', 'visibility', 'visible');
                    }
                }
            } else {
                if (map.getLayer('mrdiy-distribution-centers-layer')) {
                    map.setLayoutProperty('mrdiy-distribution-centers-layer', 'visibility', 'none');
                }
                if (map.getLayer('mrdiy-dc-connections-layer')) {
                    map.setLayoutProperty('mrdiy-dc-connections-layer', 'visibility', 'none');
                }
            }
            
            // Add Oriental Kopi distribution centers if Oriental Kopi stores are visible
            const checkOrientalKopi = (feature) => {
                const brandKey = (feature.properties.brand_key || '').toLowerCase();
                return brandKey === 'orientalkopi';
            };
            
            const hasOrientalKopi = visibleLocations && visibleLocations.some(checkOrientalKopi);
            
            if (hasOrientalKopi && showDC && window.orientalKopiDistributionCentersData && window.orientalKopiDistributionCentersData.length > 0) {
                const orientalKopiDistCentersGeoJSON = {
                    type: 'FeatureCollection',
                    features: window.orientalKopiDistributionCentersData
                };
                
                if (!map.getSource('orientalkopi-distribution-centers')) {
                    map.addSource('orientalkopi-distribution-centers', {
                        type: 'geojson',
                        data: orientalKopiDistCentersGeoJSON
                    });
                    
                    map.addLayer({
                        id: 'orientalkopi-distribution-centers-layer',
                        type: 'circle',
                        source: 'orientalkopi-distribution-centers',
                        paint: {
                            'circle-radius': 18,
                            'circle-opacity': 1.0,
                            'circle-color': '#2196F3',
                            'circle-stroke-width': 3,
                            'circle-stroke-color': '#ffffff',
                            'circle-stroke-opacity': 1.0
                        }
                    });
                    
                    const orientalKopiDcConnections = calculateOrientalKopiDCConnections();
                    
                    if (orientalKopiDcConnections.lineFeatures.length > 0) {
                        if (!map.getSource('orientalkopi-dc-connections')) {
                            map.addSource('orientalkopi-dc-connections', {
                                type: 'geojson',
                                data: {
                                    type: 'FeatureCollection',
                                    features: orientalKopiDcConnections.lineFeatures
                                }
                            });
                            
                            map.addLayer({
                                id: 'orientalkopi-dc-connections-layer',
                                type: 'line',
                                source: 'orientalkopi-dc-connections',
                                paint: {
                                    'line-color': '#2196F3',
                                    'line-width': 1,
                                    'line-opacity': 0.35
                                }
                            });
                        }
                    }
                    
                    map.on('click', 'orientalkopi-distribution-centers-layer', (e) => {
                        const coordinates = e.features[0].geometry.coordinates.slice();
                        const props = e.features[0].properties;
                        
                        new mapboxgl.Popup()
                            .setLngLat(coordinates)
                            .setHTML(`
                                <div class="popup-title">
                                    ${props.code || ''} - ${props.name || 'Distribution Center'}
                                </div>
                                <div class="popup-info">
                                    <div><strong>Oriental Kopi Distribution Center</strong></div>
                                    <div>${props.address || ''}</div>
                                    ${props.district ? `<div style="font-size:12px;color:#999;">${props.district}</div>` : ''}
                                    ${props.postcode ? `<div style="font-size:12px;color:#999;">${props.postcode}</div>` : ''}
                                    <div style="margin-top:6px;font-size:12px;color:#999;">
                                        ${props.state || ''}
                                    </div>
                                    ${props.google_maps_url ? `
                                        <div style="margin-top:6px;">
                                            <a href="${props.google_maps_url}" target="_blank" style="color:#2196F3;text-decoration:none;">
                                                View on Google Maps →
                                            </a>
                                        </div>
                                    ` : ''}
                                </div>
                            `)
                            .addTo(map);
                    });
                    
                    map.on('mouseenter', 'orientalkopi-distribution-centers-layer', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', 'orientalkopi-distribution-centers-layer', () => {
                        map.getCanvas().style.cursor = '';
                    });
                } else {
                    map.getSource('orientalkopi-distribution-centers').setData(orientalKopiDistCentersGeoJSON);
                    if (map.getLayer('orientalkopi-distribution-centers-layer')) {
                        map.setLayoutProperty('orientalkopi-distribution-centers-layer', 'visibility', 'visible');
                    }
                }
            } else {
                if (map.getLayer('orientalkopi-distribution-centers-layer')) {
                    map.setLayoutProperty('orientalkopi-distribution-centers-layer', 'visibility', 'none');
                }
                if (map.getLayer('orientalkopi-dc-connections-layer')) {
                    map.setLayoutProperty('orientalkopi-dc-connections-layer', 'visibility', 'none');
                }
            }
            
            // Handle department stores mode with separate layers (similar to convenience stores and gold shops)
            if (isDepartmentStoresMode) {
                console.log('=== DEPARTMENT STORES MODE ===');
                console.log('Department store features:', departmentStoreFeatures.length);
                
                const departmentStoresGeojson = {
                    type: 'FeatureCollection',
                    features: departmentStoreFeatures
                };
                
                // Always create/update the source, even if empty
                if (!map.getSource('departmentstores-stores')) {
                    console.log('Creating departmentstores-stores source');
                    map.addSource('departmentstores-stores', {
                        type: 'geojson',
                        data: departmentStoresGeojson,
                        cluster: true,
                        clusterMaxZoom: 14,
                        clusterRadius: 50
                    });
                } else {
                    console.log('Updating departmentstores-stores source with', departmentStoresGeojson.features.length, 'features');
                    map.getSource('departmentstores-stores').setData(departmentStoresGeojson);
                }

                // Always add layers - they'll be hidden if no data
                console.log('Adding department stores layers, hasData:', departmentStoreFeatures.length > 0);
                addStoreLayers('departmentstores-stores', departmentStoreFeatures.length > 0, 'departmentstores');
                
                // Create non-clustered source for when clustering is disabled
                if (!map.getSource('departmentstores-stores-nocluster')) {
                    map.addSource('departmentstores-stores-nocluster', {
                        type: 'geojson',
                        data: departmentStoresGeojson
                    });
                    
                    map.addLayer({
                        id: 'departmentstores-nocluster-layer',
                        type: 'circle',
                        source: 'departmentstores-stores-nocluster',
                        layout: {
                            visibility: 'none' // Hidden by default (clustering enabled)
                        },
                        paint: {
                            'circle-radius': 5,
                            'circle-opacity': 1.0,
                            'circle-color': [
                                'coalesce',
                                ['get', 'color'],
                                [
                                    'match',
                                    ['get', 'brand_key'],
                                    'parksonaeon', '#9C27B0',  // Purple
                                    'parkson', '#9C27B0',  // Purple
                                    'aeon', '#A0008E',
                                    '#666666'
                                ]
                            ],
                            'circle-stroke-width': 1.5,
                            'circle-stroke-color': '#ffffff',
                            'circle-stroke-opacity': 1.0
                        }
                    });
                    
                    // Add click handler for non-clustered layer
                    map.on('click', 'departmentstores-nocluster-layer', (e) => {
                        const coordinates = e.features[0].geometry.coordinates.slice();
                        const props = e.features[0].properties;
                        
                        new mapboxgl.Popup()
                            .setLngLat(coordinates)
                            .setHTML(`
                                <div class="popup-title">
                                    ${props.store_code} - ${props.store_name}
                                </div>
                                <div class="popup-info">
                                    <div>${props.address}</div>
                                    ${formatLocationDisplay(props)}
                                    <div style="margin-top:6px;font-size:12px;color:#999;">
                                        ${props.brand || ''}${props.sector ? ` · ${props.sector}` : ''}
                                    </div>
                                </div>
                            `)
                            .addTo(map);
                    });
                    
                    // Hover effects
                    map.on('mouseenter', 'departmentstores-nocluster-layer', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', 'departmentstores-nocluster-layer', () => {
                        map.getCanvas().style.cursor = '';
                    });
                } else {
                    // Update existing source
                    map.getSource('departmentstores-stores-nocluster').setData(departmentStoresGeojson);
                }
                
                // Force visibility if we have data
                if (departmentStoreFeatures.length > 0) {
                    console.log('Setting department stores layers to visible');
                    setTimeout(() => {
                        if (map.getLayer('departmentstores-clusters')) {
                            map.setLayoutProperty('departmentstores-clusters', 'visibility', 'visible');
                        }
                        if (map.getLayer('departmentstores-cluster-count')) {
                            map.setLayoutProperty('departmentstores-cluster-count', 'visibility', 'visible');
                        }
                        if (map.getLayer('departmentstores-points')) {
                            map.setLayoutProperty('departmentstores-points', 'visibility', 'visible');
                        }
                    }, 100);
                }
                
                // Ensure department stores are on top of districts
                const reorderDepartmentStoresLayers = () => {
                    try {
                        let targetLayer = null;
                        
                        if (map.getLayer('departmentstores-clusters')) {
                            targetLayer = 'departmentstores-clusters';
                        } else if (map.getLayer('departmentstores-cluster-count')) {
                            targetLayer = 'departmentstores-cluster-count';
                        } else if (map.getLayer('departmentstores-points')) {
                            targetLayer = 'departmentstores-points';
                        } else if (map.getLayer('departmentstores-nocluster-layer')) {
                            targetLayer = 'departmentstores-nocluster-layer';
                        }
                        
                        if (targetLayer) {
                            if (map.getLayer('district-borders')) {
                                map.moveLayer('district-borders', targetLayer);
                            }
                            if (map.getLayer('district-fills')) {
                                map.moveLayer('district-fills', targetLayer);
                            }
                            console.log('Moved districts below department stores (target:', targetLayer, ')');
                        }
                    } catch (e) {
                        console.warn('Could not reorder department stores layers:', e);
                    }
                };
                
                setTimeout(reorderDepartmentStoresLayers, 200);
                setTimeout(reorderDepartmentStoresLayers, 500);
                setTimeout(reorderDepartmentStoresLayers, 1000);
                setTimeout(reorderDepartmentStoresLayers, 1500);

                // Hide old single-layer stores if they exist
                if (map.getLayer('clusters')) {
                    map.setLayoutProperty('clusters', 'visibility', 'none');
                }
                if (map.getLayer('cluster-count')) {
                    map.setLayoutProperty('cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('unclustered-point')) {
                    map.setLayoutProperty('unclustered-point', 'visibility', 'none');
                }
                if (map.getLayer('stores-nocluster-layer')) {
                    map.setLayoutProperty('stores-nocluster-layer', 'visibility', 'none');
                }
                
                return;
            }
            
            // Handle fast fashion mode with separate layers (similar to convenience stores and gold shops)
            if (isFastFashionMode) {
                console.log('=== FAST FASHION MODE ===');
                console.log('Fast fashion features to add to map:', fastFashionFeatures.length);
                console.log('Fast fashion locations array length:', fastFashionLocations.length);
                console.log('Visible locations length:', visibleLocations.length);
                
                // Count actual points that will be displayed
                if (fastFashionFeatures.length > 0) {
                    const brandBreakdown = {};
                    fastFashionFeatures.forEach(f => {
                        const brand = f.properties.brand || 'Unknown';
                        brandBreakdown[brand] = (brandBreakdown[brand] || 0) + 1;
                    });
                    console.log('Fast Fashion brand breakdown:', brandBreakdown);
                }
                
                const fastFashionGeojson = {
                    type: 'FeatureCollection',
                    features: fastFashionFeatures
                };
                
                // Always create/update the source, even if empty
                if (!map.getSource('fastfashion-stores')) {
                    console.log('Creating fastfashion-stores source');
                    map.addSource('fastfashion-stores', {
                        type: 'geojson',
                        data: fastFashionGeojson,
                        cluster: true,
                        clusterMaxZoom: 14,
                        clusterRadius: 50
                    });
                } else {
                    console.log('Updating fastfashion-stores source with', fastFashionGeojson.features.length, 'features');
                    map.getSource('fastfashion-stores').setData(fastFashionGeojson);
                }

                // Always add layers - they'll be hidden if no data
                console.log('Adding fast fashion layers, hasData:', fastFashionFeatures.length > 0);
                addStoreLayers('fastfashion-stores', fastFashionFeatures.length > 0, 'fastfashion');
                
                // Create non-clustered source for when clustering is disabled
                if (!map.getSource('fastfashion-stores-nocluster')) {
                    map.addSource('fastfashion-stores-nocluster', {
                        type: 'geojson',
                        data: fastFashionGeojson
                    });
                    
                    map.addLayer({
                        id: 'fastfashion-nocluster-layer',
                        type: 'circle',
                        source: 'fastfashion-stores-nocluster',
                        layout: {
                            visibility: 'none' // Hidden by default (clustering enabled)
                        },
                        paint: {
                            'circle-radius': 5,
                            'circle-opacity': 1.0,
                            'circle-color': [
                                'coalesce',
                                ['get', 'color'],
                                [
                                    'match',
                                    ['get', 'brand_key'],
                                    'padini', '#000000',
                                    'hnm', '#C8102E',
                                    'uniqlo', '#E60012',
                                    'hla', '#002F6C',
                                    '#666666'
                                ]
                            ],
                            'circle-stroke-width': 1.5,
                            'circle-stroke-color': '#ffffff',
                            'circle-stroke-opacity': 1.0
                        }
                    });
                    
                    // Add click handler for non-clustered layer
                    map.on('click', 'fastfashion-nocluster-layer', (e) => {
                        const coordinates = e.features[0].geometry.coordinates.slice();
                        const props = e.features[0].properties;
                        
                        new mapboxgl.Popup()
                            .setLngLat(coordinates)
                            .setHTML(`
                                <div class="popup-title">
                                    ${props.store_code} - ${props.store_name}
                                </div>
                                <div class="popup-info">
                                    <div>${props.address}</div>
                                    ${formatLocationDisplay(props)}
                                    <div style="margin-top:6px;font-size:12px;color:#999;">
                                        ${props.brand || ''}${props.sector ? ` · ${props.sector}` : ''}
                                    </div>
                                </div>
                            `)
                            .addTo(map);
                    });
                    
                    // Hover effects
                    map.on('mouseenter', 'fastfashion-nocluster-layer', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', 'fastfashion-nocluster-layer', () => {
                        map.getCanvas().style.cursor = '';
                    });
                } else {
                    // Update existing source
                    map.getSource('fastfashion-stores-nocluster').setData(fastFashionGeojson);
                }
                
                // Force visibility if we have data
                if (fastFashionFeatures.length > 0) {
                    console.log('Setting fast fashion layers to visible');
                    setTimeout(() => {
                        if (map.getLayer('fastfashion-clusters')) {
                            map.setLayoutProperty('fastfashion-clusters', 'visibility', 'visible');
                        }
                        if (map.getLayer('fastfashion-cluster-count')) {
                            map.setLayoutProperty('fastfashion-cluster-count', 'visibility', 'visible');
                        }
                        if (map.getLayer('fastfashion-points')) {
                            map.setLayoutProperty('fastfashion-points', 'visibility', 'visible');
                        }
                    }, 100);
                }
                
                // Ensure fast fashion are on top of districts
                const reorderFastFashionLayers = () => {
                    try {
                        let targetLayer = null;
                        
                        if (map.getLayer('fastfashion-clusters')) {
                            targetLayer = 'fastfashion-clusters';
                        } else if (map.getLayer('fastfashion-cluster-count')) {
                            targetLayer = 'fastfashion-cluster-count';
                        } else if (map.getLayer('fastfashion-points')) {
                            targetLayer = 'fastfashion-points';
                        } else if (map.getLayer('fastfashion-nocluster-layer')) {
                            targetLayer = 'fastfashion-nocluster-layer';
                        }
                        
                        if (targetLayer) {
                            if (map.getLayer('district-borders')) {
                                map.moveLayer('district-borders', targetLayer);
                            }
                            if (map.getLayer('district-fills')) {
                                map.moveLayer('district-fills', targetLayer);
                            }
                            console.log('Moved districts below fast fashion (target:', targetLayer, ')');
                        }
                    } catch (e) {
                        console.warn('Could not reorder fast fashion layers:', e);
                    }
                };
                
                setTimeout(reorderFastFashionLayers, 200);
                setTimeout(reorderFastFashionLayers, 500);
                setTimeout(reorderFastFashionLayers, 1000);
                setTimeout(reorderFastFashionLayers, 1500);

                // Hide old single-layer stores if they exist
                if (map.getLayer('clusters')) {
                    map.setLayoutProperty('clusters', 'visibility', 'none');
                }
                if (map.getLayer('cluster-count')) {
                    map.setLayoutProperty('cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('unclustered-point')) {
                    map.setLayoutProperty('unclustered-point', 'visibility', 'none');
                }
                if (map.getLayer('stores-nocluster-layer')) {
                    map.setLayoutProperty('stores-nocluster-layer', 'visibility', 'none');
                }
                
                return;
            }
            
            // Hide normal store layers when in convenience stores, gold shops, department stores, or fast fashion mode
            if (isConvenienceStoresMode || isGoldShopsMode || isDepartmentStoresMode || isFastFashionMode) {
                if (map.getLayer('clusters')) {
                    map.setLayoutProperty('clusters', 'visibility', 'none');
                }
                if (map.getLayer('cluster-count')) {
                    map.setLayoutProperty('cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('unclustered-point')) {
                    map.setLayoutProperty('unclustered-point', 'visibility', 'none');
                }
                if (map.getLayer('stores-nocluster-layer')) {
                    map.setLayoutProperty('stores-nocluster-layer', 'visibility', 'none');
                }
            }

            // Handle gold shops mode with separate layers (similar to convenience stores)
            if (isGoldShopsMode) {
                console.log('=== GOLD SHOPS MODE ===');
                console.log('Gold shop features:', goldShopFeatures.length);
                console.log('Gold shop locations:', goldShopLocations.length);
                
                // Always create/update the source, even if empty
                if (!map.getSource('goldshops-stores')) {
                    console.log('Creating goldshops-stores source');
                    map.addSource('goldshops-stores', {
                        type: 'geojson',
                        data: goldShopsGeojson,
                        cluster: true,
                        clusterMaxZoom: 14,
                        clusterRadius: 50
                    });
                } else {
                    console.log('Updating goldshops-stores source with', goldShopsGeojson.features.length, 'features');
                    map.getSource('goldshops-stores').setData(goldShopsGeojson);
                }

                // Always add layers - they'll be hidden if no data
                console.log('Adding gold shops layers, hasData:', goldShopFeatures.length > 0);
                addStoreLayers('goldshops-stores', goldShopFeatures.length > 0, 'goldshops');
                
                // Create non-clustered source for when clustering is disabled
                if (!map.getSource('goldshops-stores-nocluster')) {
                    map.addSource('goldshops-stores-nocluster', {
                        type: 'geojson',
                        data: goldShopsGeojson
                    });
                    
                    map.addLayer({
                        id: 'goldshops-nocluster-layer',
                        type: 'circle',
                        source: 'goldshops-stores-nocluster',
                        layout: {
                            visibility: 'none' // Hidden by default (clustering enabled)
                        },
                        paint: {
                            'circle-radius': 5,
                            'circle-opacity': 1.0,
                            'circle-color': [
                                'coalesce',
                                ['get', 'color'],
                                [
                                    'match',
                                    ['get', 'brand_key'],
                                    'tomei', '#D4AF37',
                                    'pohkong', '#C49B3C',
                                    'habib', '#B8860B',
                                    'wahchan', '#A67C00',
                                    '#666666'
                                ]
                            ],
                            'circle-stroke-width': 1.5,
                            'circle-stroke-color': '#ffffff',
                            'circle-stroke-opacity': 1.0
                        }
                    });
                    
                    // Add click handler for non-clustered layer
                    map.on('click', 'goldshops-nocluster-layer', (e) => {
                        const coordinates = e.features[0].geometry.coordinates.slice();
                        const props = e.features[0].properties;
                        
                        new mapboxgl.Popup()
                            .setLngLat(coordinates)
                            .setHTML(`
                                <div class="popup-title">
                                    ${props.store_code} - ${props.store_name}
                                </div>
                                <div class="popup-info">
                                    <div>${props.address}</div>
                                    ${formatLocationDisplay(props)}
                                    <div style="margin-top:6px;font-size:12px;color:#999;">
                                        ${props.brand || ''}${props.sector ? ` · ${props.sector}` : ''}
                                    </div>
                                </div>
                            `)
                            .addTo(map);
                    });
                    
                    // Hover effects
                    map.on('mouseenter', 'goldshops-nocluster-layer', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', 'goldshops-nocluster-layer', () => {
                        map.getCanvas().style.cursor = '';
                    });
                } else {
                    // Update existing source
                    map.getSource('goldshops-stores-nocluster').setData(goldShopsGeojson);
                }
                
                // Force visibility if we have data
                if (goldShopFeatures.length > 0) {
                    console.log('Setting gold shops layers to visible');
                    setTimeout(() => {
                        if (map.getLayer('goldshops-clusters')) {
                            map.setLayoutProperty('goldshops-clusters', 'visibility', 'visible');
                        }
                        if (map.getLayer('goldshops-cluster-count')) {
                            map.setLayoutProperty('goldshops-cluster-count', 'visibility', 'visible');
                        }
                        if (map.getLayer('goldshops-points')) {
                            map.setLayoutProperty('goldshops-points', 'visibility', 'visible');
                        }
                    }, 100);
                }
                
                // Ensure gold shops are on top of districts
                const reorderGoldShopsLayers = () => {
                    try {
                        let targetLayer = null;
                        
                        // Check for cluster layers first
                        if (map.getLayer('goldshops-clusters')) {
                            targetLayer = 'goldshops-clusters';
                        } else if (map.getLayer('goldshops-cluster-count')) {
                            targetLayer = 'goldshops-cluster-count';
                        } else if (map.getLayer('goldshops-points')) {
                            targetLayer = 'goldshops-points';
                        } else if (map.getLayer('goldshops-nocluster-layer')) {
                            targetLayer = 'goldshops-nocluster-layer';
                        }
                        
                        if (targetLayer) {
                            if (map.getLayer('district-borders')) {
                                map.moveLayer('district-borders', targetLayer);
                            }
                            if (map.getLayer('district-fills')) {
                                map.moveLayer('district-fills', targetLayer);
                            }
                            console.log('Moved districts below gold shops (target:', targetLayer, ')');
                        }
                    } catch (e) {
                        console.warn('Could not reorder gold shops layers:', e);
                    }
                };
                
                setTimeout(reorderGoldShopsLayers, 200);
                setTimeout(reorderGoldShopsLayers, 500);
                setTimeout(reorderGoldShopsLayers, 1000);
                setTimeout(reorderGoldShopsLayers, 1500);

                // Hide old single-layer stores if they exist
                if (map.getLayer('clusters')) {
                    map.setLayoutProperty('clusters', 'visibility', 'none');
                }
                if (map.getLayer('cluster-count')) {
                    map.setLayoutProperty('cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('unclustered-point')) {
                    map.setLayoutProperty('unclustered-point', 'visibility', 'none');
                }
                if (map.getLayer('stores-nocluster-layer')) {
                    map.setLayoutProperty('stores-nocluster-layer', 'visibility', 'none');
                }
                
                return;
            }

            // Normal mode: single layer for all stores (for other categories if any)
            // Create or update a GeoJSON source for clustering
            if (!map.getSource('stores')) {
                map.addSource('stores', {
                    type: 'geojson',
                    data: geojsonData,
                    cluster: true,
                    clusterMaxZoom: 14,
                    clusterRadius: 50
                });
            } else {
                // Always update with current filtered data (even if empty)
                map.getSource('stores').setData(geojsonData);
            }
            
            // If no features, hide all marker layers
            if (features.length === 0) {
                if (map.getLayer('clusters')) {
                    map.setLayoutProperty('clusters', 'visibility', 'none');
                }
                if (map.getLayer('cluster-count')) {
                    map.setLayoutProperty('cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('unclustered-point')) {
                    map.setLayoutProperty('unclustered-point', 'visibility', 'none');
                }
                if (map.getLayer('stores-nocluster-layer')) {
                    map.setLayoutProperty('stores-nocluster-layer', 'visibility', 'none');
                }
                return; // Don't add layers if no data
            }
            
            // Show layers if we have data
            if (map.getLayer('clusters')) {
                map.setLayoutProperty('clusters', 'visibility', 'visible');
            }
            if (map.getLayer('cluster-count')) {
                map.setLayoutProperty('cluster-count', 'visibility', 'visible');
            }
            if (map.getLayer('unclustered-point')) {
                map.setLayoutProperty('unclustered-point', 'visibility', 'visible');
            }

            // Add cluster circles
            if (!map.getLayer('clusters')) {
                map.addLayer({
                    id: 'clusters',
                    type: 'circle',
                    source: 'stores',
                    filter: ['has', 'point_count'],
                    paint: {
                        'circle-opacity': 1.0,
                        'circle-color': [
                            'step',
                            ['get', 'point_count'],
                            '#ff9999',
                            10,
                            '#ff6666',
                            30,
                            '#ff3333',
                            50,
                            '#ff0000'
                        ],
                        'circle-radius': [
                            'step',
                            ['get', 'point_count'],
                            12,
                            10,
                            18,
                            30,
                            24,
                            50,
                            30
                        ],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#fff',
                        'circle-stroke-opacity': 1.0
                    }
                });
            } else {
                // Update existing layer to ensure full opacity
                map.setPaintProperty('clusters', 'circle-opacity', 1.0);
                map.setPaintProperty('clusters', 'circle-stroke-opacity', 1.0);
            }

            // Add cluster count labels
            if (!map.getLayer('cluster-count')) {
                map.addLayer({
                    id: 'cluster-count',
                    type: 'symbol',
                    source: 'stores',
                    filter: ['has', 'point_count'],
                    layout: {
                        'text-field': '{point_count_abbreviated}',
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': 12
                    },
                    paint: {
                        'text-color': '#ffffff'
                    }
                });
            }

            // Add unclustered point markers (simple circles)
            // Use the color property from features, or fallback to brand_key matching
            if (!map.getLayer('unclustered-point')) {
                map.addLayer({
                    id: 'unclustered-point',
                    type: 'circle',
                    source: 'stores',
                    filter: ['!', ['has', 'point_count']],
                    paint: {
                        'circle-radius': 5,
                        'circle-opacity': 1.0,
                        'circle-color': [
                            'coalesce',
                            ['get', 'color'],
                            [
                                'match',
                                ['get', 'brand_key'],
                                'mrdiy', '#FFC82E',
                                'mrtoy', '#E53935',
                                'ecoshop', '#4CAF50',
                                'familymart', '#00BFA5',
                                'mynews', '#D50000',
                                'kkmart', '#FB8C00',
                                'kksupermart', '#FB8C00',
                                'speedmart', '#FF9800',  // Orange
                                'orientalkopi', '#6D4C41',
                                'oldtown', '#8D6E63',
                                'teagarden', '#81C784',
                                'memangmeow', '#9C27B0',
                                'padini', '#000000',
                                'hnm', '#C8102E',
                                'uniqlo', '#E60012',
                                'hla', '#002F6C',
                                'parkson', '#9C27B0',  // Purple
                                'parksonaeon', '#9C27B0',  // Purple
                                'aeon', '#A0008E',
                                'tomei', '#D4AF37',
                                'pohkong', '#C49B3C',
                                'habib', '#B8860B',
                                'wahchan', '#A67C00',
                                '7eleven', '#00A859',
                                '#666666'
                            ]
                        ],
                        'circle-stroke-width': 1.5,
                        'circle-stroke-color': '#ffffff',
                        'circle-stroke-opacity': 1.0
                    }
                });
            } else {
                // Update existing layer to ensure full opacity
                map.setPaintProperty('unclustered-point', 'circle-opacity', 1.0);
                map.setPaintProperty('unclustered-point', 'circle-stroke-opacity', 1.0);
            }

            // Non-clustered source/layer for toggle
            if (!map.getSource('stores-nocluster')) {
                map.addSource('stores-nocluster', {
                    type: 'geojson',
                    data: geojsonData
                });
            } else {
                // Always update the source with current filtered data
                map.getSource('stores-nocluster').setData(geojsonData);
            }
            
            if (!map.getLayer('stores-nocluster-layer')) {

                map.addLayer({
                    id: 'stores-nocluster-layer',
                    type: 'circle',
                    source: 'stores-nocluster',
                    layout: {
                        visibility: 'none'
                    },
                    paint: {
                        'circle-radius': 5,
                        'circle-opacity': 1.0,
                        'circle-color': [
                            'coalesce',
                            ['get', 'color'],
                            [
                                'match',
                                ['get', 'brand_key'],
                                'mrdiy', '#FFC82E',
                                'mrtoy', '#E53935',
                                'ecoshop', '#4CAF50',
                                'familymart', '#00BFA5',
                                'mynews', '#D50000',
                                'kkmart', '#FB8C00',
                                'kksupermart', '#FB8C00',
                                'speedmart', '#FF9800',  // Orange
                                'orientalkopi', '#6D4C41',
                                'oldtown', '#8D6E63',
                                'teagarden', '#81C784',
                                'memangmeow', '#9C27B0',
                                'padini', '#000000',
                                'hnm', '#C8102E',
                                'uniqlo', '#E60012',
                                'hla', '#002F6C',
                                'parkson', '#9C27B0',  // Purple
                                'parksonaeon', '#9C27B0',  // Purple
                                'aeon', '#A0008E',
                                'tomei', '#D4AF37',
                                'pohkong', '#C49B3C',
                                'habib', '#B8860B',
                                'wahchan', '#A67C00',
                                '7eleven', '#00A859',
                                '#666666'
                            ]
                        ],
                        'circle-stroke-width': 1.5,
                        'circle-stroke-color': '#ffffff',
                        'circle-stroke-opacity': 1.0
                    }
                });
            } else {
                // Update existing layer to ensure full opacity
                map.setPaintProperty('stores-nocluster-layer', 'circle-opacity', 1.0);
                map.setPaintProperty('stores-nocluster-layer', 'circle-stroke-opacity', 1.0);
                // Always update source data with current filtered data
                if (map.getSource('stores-nocluster')) {
                    map.getSource('stores-nocluster').setData(geojsonData);
                }
            }

            // Ensure marker layers are above district layers (so markers appear on top)
            // (Note: convenience stores mode handles this in its own section above)
            const reorderNormalLayers = () => {
                try {
                    if (map.getLayer('district-fills')) {
                        // Normal mode - move districts below markers (this puts markers above)
                        if (map.getLayer('clusters')) {
                            map.moveLayer('district-fills', 'clusters');
                            map.moveLayer('district-borders', 'clusters');
                        } else if (map.getLayer('cluster-count')) {
                            map.moveLayer('district-fills', 'cluster-count');
                            map.moveLayer('district-borders', 'cluster-count');
                        } else if (map.getLayer('unclustered-point')) {
                            map.moveLayer('district-fills', 'unclustered-point');
                            map.moveLayer('district-borders', 'unclustered-point');
                        } else if (map.getLayer('stores-nocluster-layer')) {
                            map.moveLayer('district-fills', 'stores-nocluster-layer');
                            map.moveLayer('district-borders', 'stores-nocluster-layer');
                        }
                    }
                } catch (e) {
                    console.warn('Could not reorder marker layers:', e);
                }
            };
            
            // Try multiple times to ensure layers are ready
            setTimeout(reorderNormalLayers, 200);
            setTimeout(reorderNormalLayers, 500);
            setTimeout(reorderNormalLayers, 1000);
            setTimeout(reorderNormalLayers, 1500);
            
            // Ensure district layers stay at bottom
            setTimeout(ensureDistrictLayersAtBottom, 300);
            setTimeout(ensureDistrictLayersAtBottom, 600);
            setTimeout(ensureDistrictLayersAtBottom, 1100);
            setTimeout(ensureDistrictLayersAtBottom, 1600);

            // Add click handler for stores-nocluster-layer (only add once, but update source data always)
            if (map.getSource('stores-nocluster') && map.getLayer('stores-nocluster-layer')) {
                // Update source data with current filtered data
                map.getSource('stores-nocluster').setData(geojsonData);
                
                // Only add click handler once (check if it's already been added)
                if (!map.getLayer('stores-nocluster-layer')._clickHandlerAdded) {
                    map.on('click', 'stores-nocluster-layer', (e) => {
                        const coordinates = e.features[0].geometry.coordinates.slice();
                        const props = e.features[0].properties;

                        new mapboxgl.Popup()
                            .setLngLat(coordinates)
                            .setHTML(`
                                <div class="popup-title">
                                    ${props.store_code} - ${props.store_name}
                                </div>
                                <div class="popup-info">
                                    <div>${props.address}</div>
                                    ${formatLocationDisplay(props)}
                                    <div style="margin-top:6px;font-size:12px;color:#999;">
                                        ${props.brand || ''}${props.sector ? ` · ${props.sector}` : ''}
                                    </div>
                                </div>
                            `)
                            .addTo(map);
                    });
                    map.getLayer('stores-nocluster-layer')._clickHandlerAdded = true;
                }
            }

            // Click on cluster to zoom in
            map.on('click', 'clusters', (e) => {
                const features = map.queryRenderedFeatures(e.point, {
                    layers: ['clusters']
                });
                const clusterId = features[0].properties.cluster_id;
                map.getSource('stores').getClusterExpansionZoom(
                    clusterId,
                    (err, zoom) => {
                        if (err) return;

                        map.easeTo({
                            center: features[0].geometry.coordinates,
                            zoom: zoom
                        });
                    }
                );
            });

            // Show popup on unclustered point click
            map.on('click', 'unclustered-point', (e) => {
                const coordinates = e.features[0].geometry.coordinates.slice();
                const props = e.features[0].properties;

                new mapboxgl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(`
                        <div class="popup-title">
                            ${props.store_code} - ${props.store_name}
                        </div>
                        <div class="popup-info">
                            <div>${props.address}</div>
                            ${formatLocationDisplay(props)}
                            <div style="margin-top:6px;font-size:12px;color:#999;">
                                ${props.brand || ''}${props.sector ? ` · ${props.sector}` : ''}
                            </div>
                        </div>
                    `)
                    .addTo(map);
            });

            // Change cursor on hover
            map.on('mouseenter', 'clusters', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'clusters', () => {
                map.getCanvas().style.cursor = '';
            });
            map.on('mouseenter', 'unclustered-point', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'unclustered-point', () => {
                map.getCanvas().style.cursor = '';
            });

            map.on('mouseenter', 'stores-nocluster-layer', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'stores-nocluster-layer', () => {
                map.getCanvas().style.cursor = '';
            });
        }

        // Function to calculate Market Power Index for all districts
        // Accepts optional storeData parameter for category-specific calculations
        function calculateMarketPowerIndex(storeData = null) {
            const storesToUse = storeData || locationsData;
            
            if (!storesToUse || storesToUse.length === 0 || !districtGeojson || !districtGeojson.features) {
                // Data not ready yet, will be called again when data loads
                return;
            }
            
            const categoryLabel = storeData ? '(filtered)' : '(all stores)';
            console.log(`Calculating store counts and Market Power Index for districts ${categoryLabel}...`);
            console.log(`Processing ${districtGeojson.features.length} districts with ${storesToUse.length} stores`);
            
            districtGeojson.features.forEach((district, index) => {
                const districtPolygon = district.geometry;
                let storeCount = 0;
                
                // Count stores within this district polygon using Turf.js
                storesToUse.forEach(store => {
                    try {
                        const storePoint = {
                            type: 'Point',
                            coordinates: store.geometry.coordinates
                        };
                        
                        // Check if store point is within district polygon
                        // Handle MultiPolygon and Polygon geometries
                        let isInside = false;
                        if (districtPolygon.type === 'Polygon') {
                            isInside = turf.booleanPointInPolygon(storePoint, districtPolygon);
                        } else if (districtPolygon.type === 'MultiPolygon') {
                            // Check each polygon in the MultiPolygon
                            districtPolygon.coordinates.forEach(polygonCoords => {
                                const polygon = {
                                    type: 'Polygon',
                                    coordinates: polygonCoords
                                };
                                if (turf.booleanPointInPolygon(storePoint, polygon)) {
                                    isInside = true;
                                }
                            });
                        }
                        
                        if (isInside) {
                            storeCount++;
                        }
                    } catch (error) {
                        // Skip stores with invalid coordinates
                        console.warn('Error checking store in district:', error);
                    }
                });
                
                // Store the count in district properties
                district.properties.store_count = storeCount;
                
                // Calculate Market Power Index: (Population × Income per capita) / Number of stores
                const population_k = district.properties.population_k;
                const income_pc = district.properties.income_pc;
                
                if (population_k != null && income_pc != null && !isNaN(population_k) && !isNaN(income_pc) && storeCount > 0) {
                    // Population is in thousands, so multiply by 1000
                    const marketPowerIndex = (population_k * 1000 * income_pc) / storeCount;
                    district.properties.market_power_index = marketPowerIndex;
                } else {
                    // Handle edge cases: no stores, missing data
                    district.properties.market_power_index = null;
                }
            });
            
            // Update the map source with new data
            if (map.getSource('districts')) {
                map.getSource('districts').setData(districtGeojson);
            }
            
            // Update choropleth if Market Power Index is selected
            if (currentMetric === 'market_power_index') {
                updateDistrictChoropleth('market_power_index');
            }
            
            console.log('Market Power Index calculation complete');
        }

        // Function to get MPI statistics for analytics
        function getMPIStatistics() {
            if (!districtGeojson || !districtGeojson.features) {
                return null;
            }
            
            // Filter districts with valid MPI
            const districtsWithMPI = districtGeojson.features
                .filter(d => d.properties.market_power_index != null && !isNaN(d.properties.market_power_index))
                .map(d => ({
                    name: d.properties.name || d.properties.district || 'Unknown',
                    state: d.properties.state || '',
                    mpi: d.properties.market_power_index,
                    stores: d.properties.store_count || 0,
                    population: d.properties.population_k || 0,
                    income: d.properties.income_pc || 0
                }));
            
            if (districtsWithMPI.length === 0) {
                return null;
            }
            
            // Sort by MPI (descending)
            districtsWithMPI.sort((a, b) => b.mpi - a.mpi);
            
            return {
                top10: districtsWithMPI.slice(0, 10),
                bottom10: districtsWithMPI.slice(-10).reverse(),
                highest: districtsWithMPI[0],
                lowest: districtsWithMPI[districtsWithMPI.length - 1],
                average: districtsWithMPI.reduce((sum, d) => sum + d.mpi, 0) / districtsWithMPI.length,
                totalDistricts: districtsWithMPI.length
            };
        }

        // Function to count districts that contain at least one store
        function countDistrictsWithStores(storeData) {
            if (!storeData || storeData.length === 0 || !districtGeojson || !districtGeojson.features) {
                return 0;
            }
            
            let districtsWithStores = 0;
            
            // Check each district to see if it contains any stores
            districtGeojson.features.forEach(district => {
                const districtPolygon = district.geometry;
                let hasStore = false;
                
                // Check if any store is within this district polygon
                for (let i = 0; i < storeData.length && !hasStore; i++) {
                    const store = storeData[i];
                    try {
                        const storePoint = {
                            type: 'Point',
                            coordinates: store.geometry.coordinates
                        };
                        
                        // Check if store point is within district polygon
                        let isInside = false;
                        if (districtPolygon.type === 'Polygon') {
                            isInside = turf.booleanPointInPolygon(storePoint, districtPolygon);
                        } else if (districtPolygon.type === 'MultiPolygon') {
                            districtPolygon.coordinates.forEach(polygonCoords => {
                                const polygon = {
                                    type: 'Polygon',
                                    coordinates: polygonCoords
                                };
                                if (turf.booleanPointInPolygon(storePoint, polygon)) {
                                    isInside = true;
                                }
                            });
                        }
                        
                        if (isInside) {
                            hasStore = true;
                        }
                    } catch (error) {
                        continue;
                    }
                }
                
                if (hasStore) {
                    districtsWithStores++;
                }
            });
            
            return districtsWithStores;
        }

        async function loadDistrictOverlay() {
            try {
                const res = await fetch('/api/districts');
                const geo = await res.json();

                if (!geo || !geo.features) {
                    console.error('No district features returned');
                    return;
                }

                districtGeojson = geo;

                // Count stores per district and calculate Market Power Index
                // This will be recalculated when store data is available
                calculateMarketPowerIndex();

                if (!map.getSource('districts')) {
                    map.addSource('districts', {
                        type: 'geojson',
                        data: districtGeojson
                    });
                } else {
                    map.getSource('districts').setData(districtGeojson);
                }

                if (!map.getLayer('district-fills')) {
                    map.addLayer({
                        id: 'district-fills',
                        type: 'fill',
                        source: 'districts',
                        paint: {
                            'fill-color': getDistrictColorExpression('population_k'),
                            'fill-opacity': 0.7
                        }
                    });
                } else {
                    map.setPaintProperty('district-fills', 'fill-color', getDistrictColorExpression('population_k'));
                    map.setPaintProperty('district-fills', 'fill-opacity', 0.7);
                }

                if (!map.getLayer('district-borders')) {
                    map.addLayer({
                        id: 'district-borders',
                        type: 'line',
                        source: 'districts',
                        paint: {
                            'line-color': '#333333',
                            'line-width': 0.6,
                            'line-opacity': 0.9
                        }
                    });
                } else {
                    // Update existing border layer to be more visible
                    map.setPaintProperty('district-borders', 'line-color', '#333333');
                    map.setPaintProperty('district-borders', 'line-width', 0.6);
                    map.setPaintProperty('district-borders', 'line-opacity', 0.9);
                }

                // Ensure district polygons are drawn BENEATH marker layers
                // Move district layers to be below any marker layers
                try {
                    // Priority: convenience stores > gold shops > normal stores > districts
                    // Check convenience stores first
                    if (map.getLayer('convenience-clusters')) {
                        map.moveLayer('district-fills', 'convenience-clusters');
                        map.moveLayer('district-borders', 'convenience-clusters');
                    } else if (map.getLayer('convenience-cluster-count')) {
                        map.moveLayer('district-fills', 'convenience-cluster-count');
                        map.moveLayer('district-borders', 'convenience-cluster-count');
                    } else if (map.getLayer('convenience-stores-nocluster-layer')) {
                        map.moveLayer('district-fills', 'convenience-stores-nocluster-layer');
                        map.moveLayer('district-borders', 'convenience-stores-nocluster-layer');
                    } else if (map.getLayer('convenience-points')) {
                        map.moveLayer('district-fills', 'convenience-points');
                        map.moveLayer('district-borders', 'convenience-points');
                    } 
                    // Check gold shops
                    else if (map.getLayer('goldshops-clusters')) {
                        map.moveLayer('district-fills', 'goldshops-clusters');
                        map.moveLayer('district-borders', 'goldshops-clusters');
                    } else if (map.getLayer('goldshops-cluster-count')) {
                        map.moveLayer('district-fills', 'goldshops-cluster-count');
                        map.moveLayer('district-borders', 'goldshops-cluster-count');
                    } else if (map.getLayer('goldshops-nocluster-layer')) {
                        map.moveLayer('district-fills', 'goldshops-nocluster-layer');
                        map.moveLayer('district-borders', 'goldshops-nocluster-layer');
                    } else if (map.getLayer('goldshops-points')) {
                        map.moveLayer('district-fills', 'goldshops-points');
                        map.moveLayer('district-borders', 'goldshops-points');
                    }
                    // Check department stores
                    else if (map.getLayer('departmentstores-clusters')) {
                        map.moveLayer('district-fills', 'departmentstores-clusters');
                        map.moveLayer('district-borders', 'departmentstores-clusters');
                    } else if (map.getLayer('departmentstores-cluster-count')) {
                        map.moveLayer('district-fills', 'departmentstores-cluster-count');
                        map.moveLayer('district-borders', 'departmentstores-cluster-count');
                    } else if (map.getLayer('departmentstores-nocluster-layer')) {
                        map.moveLayer('district-fills', 'departmentstores-nocluster-layer');
                        map.moveLayer('district-borders', 'departmentstores-nocluster-layer');
                    } else if (map.getLayer('departmentstores-points')) {
                        map.moveLayer('district-fills', 'departmentstores-points');
                        map.moveLayer('district-borders', 'departmentstores-points');
                    }
                    // Check fast fashion
                    else if (map.getLayer('fastfashion-clusters')) {
                        map.moveLayer('district-fills', 'fastfashion-clusters');
                        map.moveLayer('district-borders', 'fastfashion-clusters');
                    } else if (map.getLayer('fastfashion-cluster-count')) {
                        map.moveLayer('district-fills', 'fastfashion-cluster-count');
                        map.moveLayer('district-borders', 'fastfashion-cluster-count');
                    } else if (map.getLayer('fastfashion-nocluster-layer')) {
                        map.moveLayer('district-fills', 'fastfashion-nocluster-layer');
                        map.moveLayer('district-borders', 'fastfashion-nocluster-layer');
                    } else if (map.getLayer('fastfashion-points')) {
                        map.moveLayer('district-fills', 'fastfashion-points');
                        map.moveLayer('district-borders', 'fastfashion-points');
                    }
                    // Check normal stores
                    else if (map.getLayer('clusters')) {
                        map.moveLayer('district-fills', 'clusters');
                        map.moveLayer('district-borders', 'clusters');
                    } else if (map.getLayer('unclustered-point')) {
                        map.moveLayer('district-fills', 'unclustered-point');
                        map.moveLayer('district-borders', 'unclustered-point');
                    } else if (map.getLayer('stores-nocluster-layer')) {
                        map.moveLayer('district-fills', 'stores-nocluster-layer');
                        map.moveLayer('district-borders', 'stores-nocluster-layer');
                    }
                } catch (e) {
                    console.warn('Could not reorder district layers:', e);
                }

                // Apply current metric in case user changed it early
                updateDistrictChoropleth(currentMetric);
                
                // Initialize color scale bar
                updateColorScaleBar(currentMetric);

                // Add hover functionality to show district metrics
                setupDistrictHover();
                setupDistrictHoverTooltip();

                districtsLoaded = true;
            } catch (err) {
                console.error('Error loading district overlay:', err);
            }
        }

        async function loadStateBorders() {
            try {
                const res = await fetch('/api/states');
                const geo = await res.json();
                
                if (!geo || !geo.features) {
                    console.error('No state features returned');
                    return;
                }
                
                if (!map.getSource('states')) {
                    map.addSource('states', {
                        type: 'geojson',
                        data: geo
                    });
                } else {
                    map.getSource('states').setData(geo);
                }
                
                if (!map.getLayer('state-borders')) {
                    map.addLayer({
                        id: 'state-borders',
                        type: 'line',
                        source: 'states',
                        paint: {
                            'line-color': '#000000',
                            'line-width': 1.2,
                            'line-opacity': 0.8
                        },
                        layout: {
                            'visibility': 'visible'
                        }
                    });
                    
                    console.log('Created state borders layer');
                } else {
                    map.setLayoutProperty('state-borders', 'visibility', 'visible');
                    map.setPaintProperty('state-borders', 'line-color', '#000000');
                    map.setPaintProperty('state-borders', 'line-width', 1.2);
                    map.setPaintProperty('state-borders', 'line-opacity', 0.8);
                }
                
                // Position state borders above district-borders but below markers
                try {
                    if (map.getLayer('district-borders')) {
                        map.moveLayer('state-borders', 'district-borders');
                        console.log('Positioned state borders above district borders');
                    }
                } catch (e) {
                    console.warn('Could not reorder state borders layer:', e);
                }
            } catch (err) {
                console.error('Error loading state borders:', err);
            }
        }

        function getDistrictColorExpression(metric) {
            if (!districtGeojson || !districtGeojson.features.length) {
                return '#d3d3d3'; // light gray for missing data
            }
            const values = districtGeojson.features
                .map(f => f.properties[metric])
                .filter(v => typeof v === 'number' && !isNaN(v));
            if (!values.length) {
                return '#d3d3d3'; // light gray for missing data
            }
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min || 1;
            const s1 = min;
            const s2 = min + range * 0.25;
            const s3 = min + range * 0.5;
            const s4 = min + range * 0.75;

            // Color scale with more non-blue colors: light green -> yellow -> orange -> red -> dark red
            // Provides better visual distinction and utilizes warmer colors more
            // Handle null/missing values with light gray
            return [
                'case',
                ['==', ['get', metric], null], '#d3d3d3',  // light gray for null
                ['!', ['has', metric]], '#d3d3d3',  // light gray if property doesn't exist
                [
                    'interpolate',
                    ['linear'],
                    ['get', metric],
                    s1, '#90EE90',   // light green (lowest)
                    s2, '#FFD700',   // gold/yellow
                    s3, '#FF8C00',   // dark orange (middle)
                    s4, '#FF4500',   // orange-red
                    max, '#8B0000'   // dark red (highest)
                ]
            ];
        }

        function updateDistrictChoropleth(metric) {
            currentMetric = metric;
            if (!districtGeojson || !map.getLayer('district-fills')) return;
            const expr = getDistrictColorExpression(metric);
            map.setPaintProperty('district-fills', 'fill-color', expr);
            updateColorScaleBar(metric);
            
            // ALWAYS ensure district layers stay at bottom after choropleth update
            setTimeout(() => ensureDistrictLayersAtBottom(), 100);
        }

        function updateColorScaleBar(metric) {
            if (!districtGeojson || !districtGeojson.features.length) return;
            
            const values = districtGeojson.features
                .map(f => f.properties[metric])
                .filter(v => typeof v === 'number' && !isNaN(v));
            
            if (!values.length) return;
            
            const min = Math.min(...values);
            const max = Math.max(...values);
            
            // Update title
            const metricLabels = {
                'population_k': 'Population (k)',
                'income_pc': 'Income per capita',
                'income_total': 'Income',
                'market_power_index': 'Market Power Index'
            };
            
            document.getElementById('color-scale-title').textContent = metricLabels[metric] || metric;
            document.getElementById('color-scale-min').textContent = Math.round(min).toLocaleString();
            document.getElementById('color-scale-max').textContent = Math.round(max).toLocaleString();
            
            // Update gradient (using the same colors as getDistrictColorExpression)
            const gradient = document.getElementById('color-scale-gradient');
            gradient.style.background = 'linear-gradient(to right, #90EE90, #FFD700, #FF8C00, #FF4500, #8B0000)';
        }

        let districtPopup = null;
        let districtHoverTooltip = null;
        let districtClickSetup = false;
        let markersVisible = true;
        let clustersVisible = true;

        // Helper function to ensure district borders are ALWAYS visible
        function ensureDistrictBordersVisible() {
            try {
                if (map.getLayer('district-borders')) {
                    map.setLayoutProperty('district-borders', 'visibility', 'visible');
                    // Also ensure opacity and styling are correct
                    map.setPaintProperty('district-borders', 'line-opacity', 0.9);
                    map.setPaintProperty('district-borders', 'line-width', 0.6);
                    map.setPaintProperty('district-borders', 'line-color', '#333333');
                    console.log('District borders forced to visible');
                }
                if (map.getLayer('district-fills')) {
                    map.setLayoutProperty('district-fills', 'visibility', 'visible');
                    console.log('District fills forced to visible');
                }
                if (map.getLayer('state-borders')) {
                    map.setLayoutProperty('state-borders', 'visibility', 'visible');
                    console.log('State borders forced to visible');
                }
            } catch (e) {
                console.warn('Error ensuring district borders visible:', e);
            }
        }
        
        // Helper function to ensure district-fills (choropleth) is ALWAYS below all markers, clusters, and lines
        function ensureDistrictLayersAtBottom() {
            try {
                // ALL layers that should be ABOVE the district choropleth
                const layersAboveChoropleth = [
                    // Distribution center markers
                    'speedmart-distribution-centers-layer',
                    'mrdiy-distribution-centers-layer',
                    'orientalkopi-distribution-centers-layer',
                    // Connection lines (must be above choropleth)
                    'speedmart-dc-connections-layer',
                    'mrdiy-dc-connections-layer',
                    'orientalkopi-dc-connections-layer',
                    // Convenience store layers
                    'convenience-clusters',
                    'convenience-cluster-count',
                    'convenience-points',
                    'convenience-stores-nocluster-layer',
                    // Gold shops layers
                    'goldshops-clusters',
                    'goldshops-cluster-count',
                    'goldshops-points',
                    'goldshops-nocluster-layer',
                    // Department stores layers
                    'departmentstores-clusters',
                    'departmentstores-cluster-count',
                    'departmentstores-points',
                    'departmentstores-nocluster-layer',
                    // Fast fashion layers
                    'fastfashion-clusters',
                    'fastfashion-cluster-count',
                    'fastfashion-points',
                    'fastfashion-nocluster-layer',
                    // General store layers
                    'clusters',
                    'cluster-count',
                    'unclustered-point',
                    'stores-nocluster-layer'
                ];
                
                // Find ALL layers that exist and should be above choropleth
                const existingLayersAbove = layersAboveChoropleth.filter(layerId => map.getLayer(layerId));
                
                if (existingLayersAbove.length > 0) {
                    // Get the actual first (lowest) layer in the current draw order
                    // We need to find which of our layers appears first in the map's layer order
                    const allLayers = map.getStyle().layers;
                    let lowestLayerAbove = null;
                    let lowestIndex = Infinity;
                    
                    // Find the layer with the lowest index (drawn first = at bottom)
                    existingLayersAbove.forEach(layerId => {
                        const index = allLayers.findIndex(l => l.id === layerId);
                        if (index !== -1 && index < lowestIndex) {
                            lowestIndex = index;
                            lowestLayerAbove = layerId;
                        }
                    });
                    
                    // If we found a layer, use it; otherwise use the first one from our list
                    if (!lowestLayerAbove && existingLayersAbove.length > 0) {
                        lowestLayerAbove = existingLayersAbove[0];
                    }
                    
                    // CRITICAL: Ensure district-fills (choropleth) is ALWAYS below all markers/clusters/lines
                    // This is the primary requirement - the choropleth must never cover markers
                    
                    // Find current position of district-fills
                    const fillsIndex = map.getLayer('district-fills') ? 
                        allLayers.findIndex(l => l.id === 'district-fills') : -1;
                    
                    // Find position of the lowest marker/cluster/line layer
                    const lowestMarkerIndex = lowestLayerAbove ? 
                        allLayers.findIndex(l => l.id === lowestLayerAbove) : -1;
                    
                    // If district-fills is at or above any marker/cluster/line, move it below
                    if (fillsIndex !== -1 && lowestMarkerIndex !== -1) {
                        if (fillsIndex >= lowestMarkerIndex) {
                            // district-fills is at or above a marker layer - FORCE it below
                            map.moveLayer('district-fills', lowestLayerAbove);
                            console.log('✓ Moved district-fills (choropleth) below markers/clusters/lines');
                        }
                    } else if (map.getLayer('district-fills') && lowestLayerAbove) {
                        // Fallback: ensure it's positioned below markers
                        map.moveLayer('district-fills', lowestLayerAbove);
                        console.log('✓ Positioned district-fills (choropleth) below markers/clusters/lines');
                    }
                    
                    // Also ensure borders are positioned correctly (above fills, below markers if possible)
                    if (map.getLayer('district-borders') && lowestLayerAbove) {
                        const bordersIndex = allLayers.findIndex(l => l.id === 'district-borders');
                        const currentFillsIndex = allLayers.findIndex(l => l.id === 'district-fills');
                        
                        // If borders are below fills, that's wrong - but don't move fills above borders
                        // Instead, just ensure borders are below markers
                        if (bordersIndex >= lowestMarkerIndex && lowestMarkerIndex !== -1) {
                            map.moveLayer('district-borders', lowestLayerAbove);
                        }
                    }
                    
                    if (map.getLayer('state-borders') && lowestLayerAbove) {
                        const stateBordersIndex = allLayers.findIndex(l => l.id === 'state-borders');
                        const lowestMarkerIdx = allLayers.findIndex(l => l.id === lowestLayerAbove);
                        
                        if (stateBordersIndex >= lowestMarkerIdx && lowestMarkerIdx !== -1) {
                            map.moveLayer('state-borders', lowestLayerAbove);
                        }
                    }
                    
                    console.log('✓ Enforced layer order: district-fills (choropleth) < district-borders < state-borders < markers/clusters/lines');
                } else {
                    // No markers/clusters/lines exist, just ensure proper order among district layers
                    if (map.getLayer('district-fills') && map.getLayer('district-borders')) {
                        map.moveLayer('district-borders', 'district-fills');
                    }
                    if (map.getLayer('district-borders') && map.getLayer('state-borders')) {
                        map.moveLayer('state-borders', 'district-borders');
                    }
                }
            } catch (e) {
                console.warn('Could not ensure district layers at bottom:', e);
            }
        }
        
        // Ensure district and state borders are always visible
        function ensureDistrictBordersVisible() {
            try {
                if (map.getLayer('district-borders')) {
                    map.setLayoutProperty('district-borders', 'visibility', 'visible');
                }
                if (map.getLayer('state-borders')) {
                    map.setLayoutProperty('state-borders', 'visibility', 'visible');
                }
            } catch (e) {
                console.warn('Could not ensure borders visible:', e);
            }
        }
        
        // Aggressively maintain layer order - run periodically
        function maintainLayerOrder() {
            ensureDistrictLayersAtBottom();
            ensureDistrictBordersVisible();
        }
        
        // Set up periodic layer order maintenance (every 500ms)
        setInterval(maintainLayerOrder, 500);
        
        // Also enforce layer order on map interactions
        map.on('moveend', maintainLayerOrder);
        map.on('zoomend', maintainLayerOrder);
        map.on('render', maintainLayerOrder);

        // Unified state management function
        function updateStoreDisplayState(markersVisibleState, clustersVisibleState) {
            markersVisible = markersVisibleState;
            clustersVisible = clustersVisibleState;
            
            // Update marker visibility
            updateMarkersVisibility(markersVisible);
            
            // Update cluster visibility
            updateClusterVisibility(clustersVisible);
            
            // ALWAYS ensure district borders and fills are visible
            ensureDistrictBordersVisible();
            
            // Update checkbox states - force the visual state
            const markersToggle = document.getElementById('markers-toggle');
            const clusterToggle = document.getElementById('cluster-toggle');
            if (markersToggle) {
                markersToggle.checked = markersVisible;
                // Force visual update
                if (markersVisible) {
                    markersToggle.setAttribute('checked', 'checked');
                } else {
                    markersToggle.removeAttribute('checked');
                }
            }
            if (clusterToggle) {
                clusterToggle.checked = clustersVisible;
                // Force visual update
                if (clustersVisible) {
                    clusterToggle.setAttribute('checked', 'checked');
                } else {
                    clusterToggle.removeAttribute('checked');
                }
            }
            
            // Update district click behavior based on whether markers/clusters are showing
            updateDistrictClickBehavior();
            
            // Update district hover tooltip based on state
            setupDistrictHoverTooltip();
        }

        // Function to enable/disable district clicks based on markers/clusters state
        function updateDistrictClickBehavior() {
            const canClickDistrict = !markersVisible && !clustersVisible;
            
            // Update cursor style
            if (map.getLayer('district-fills')) {
                // We can't disable map clicks, but we'll check in the handler
                // Just update the visual feedback
                if (!canClickDistrict) {
                    // When markers/clusters are visible, district fills should not change cursor
                    map.getCanvas().style.cursor = '';
                }
            }
        }

        function setupDistrictHover() {
            // Only setup once to avoid duplicate event listeners
            if (districtClickSetup) {
                return;
            }
            districtClickSetup = true;

            // Map state codes to full names for display
            const stateNameMap = {
                'JHR': 'Johor', 'KDH': 'Kedah', 'KTN': 'Kelantan', 'MLK': 'Melaka',
                'NSN': 'Negeri Sembilan', 'PHG': 'Pahang', 'PRK': 'Perak', 'PLS': 'Perlis',
                'PNG': 'Pulau Pinang', 'SBH': 'Sabah', 'SWK': 'Sarawak', 'SGR': 'Selangor',
                'TRG': 'Terengganu', 'WPK': 'Wp Kuala Lumpur', 'WPL': 'Wp Labuan',
                'WPP': 'Wp Putrajaya', 'KUL': 'Wp Kuala Lumpur', 'LBN': 'Wp Labuan', 'PJY': 'Wp Putrajaya'
            };

            // Show popup on click - only when markers/clusters are not showing
            map.on('click', 'district-fills', (e) => {
                // Only allow clicks when neither markers nor clusters are visible
                if (markersVisible || clustersVisible) {
                    console.log('District click disabled - markers or clusters are visible');
                    return;
                }
                // Remove any existing popup
                if (districtPopup) {
                    districtPopup.remove();
                }

                // Get the feature properties
                const props = e.features[0].properties;
                const coordinates = e.lngLat;

                // Get district name and state
                const districtName = props.name || props.district || props.District || 'Unknown District';
                let stateName = props.state || props.State || '';
                // Convert state code to full name if needed
                if (stateName && stateName.length === 3 && stateName.toUpperCase() === stateName) {
                    stateName = stateNameMap[stateName] || stateName;
                }

                // Format metrics
                const formatValue = (value) => {
                    if (value === null || value === undefined || isNaN(value)) {
                        return 'N/A';
                    }
                    if (typeof value === 'number') {
                        // Format numbers with commas
                        return value.toLocaleString('en-US', { 
                            maximumFractionDigits: value < 1 ? 2 : 0 
                        });
                    }
                    return value;
                };

                const population = formatValue(props.population_k);
                const incomePC = formatValue(props.income_pc);
                const incomeTotal = formatValue(props.income_total);
                const storeCount = props.store_count != null ? props.store_count : 0;
                const marketPowerIndex = props.market_power_index != null && !isNaN(props.market_power_index) 
                    ? props.market_power_index.toLocaleString('en-US', { maximumFractionDigits: 0 })
                    : 'N/A';

                // Build HTML content
                let html = `
                    <div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: #333;">
                        ${districtName}${stateName ? `, ${stateName}` : ''}
                    </div>
                    <div style="font-size: 12px; line-height: 1.6;">
                        <div style="margin-bottom: 4px;">
                            <strong>Population:</strong> ${population}${typeof props.population_k === 'number' ? 'k' : ''}
                        </div>
                        <div style="margin-bottom: 4px;">
                            <strong>Income per capita:</strong> ${incomePC}${typeof props.income_pc === 'number' ? ' RM' : ''}
                        </div>
                        <div style="margin-bottom: 4px;">
                            <strong>Total Income:</strong> ${incomeTotal}${typeof props.income_total === 'number' ? ' RM' : ''}
                        </div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                            <div style="margin-bottom: 4px;">
                                <strong>Number of Stores:</strong> ${storeCount}
                            </div>
                            <div>
                                <strong>Market Power Index:</strong> ${marketPowerIndex}
                            </div>
                        </div>
                    </div>
                `;

                // Create and show popup
                districtPopup = new mapboxgl.Popup({
                    closeButton: true,
                    closeOnClick: true,
                    className: 'district-popup'
                })
                    .setLngLat(coordinates)
                    .setHTML(html)
                    .addTo(map);
            });

            // Change cursor on hover to indicate clickability - only when markers/clusters are not showing
            map.on('mouseenter', 'district-fills', () => {
                // Only show pointer cursor when districts are actually clickable
                if (!markersVisible && !clustersVisible) {
                    map.getCanvas().style.cursor = 'pointer';
                }
            });
            map.on('mouseleave', 'district-fills', () => {
                map.getCanvas().style.cursor = '';
            });
        }

        // Setup district hover tooltip (only when both markers and clusters are hidden)
        let districtHoverTooltipHandler = null;
        function setupDistrictHoverTooltip() {
            // Remove existing hover tooltip if any
            if (districtHoverTooltip) {
                districtHoverTooltip.remove();
                districtHoverTooltip = null;
            }

            // Remove existing tooltip handler if it exists
            if (districtHoverTooltipHandler) {
                map.off('mouseenter', 'district-fills', districtHoverTooltipHandler.enter);
                map.off('mouseleave', 'district-fills', districtHoverTooltipHandler.leave);
                districtHoverTooltipHandler = null;
            }

            // Only add tooltip if both markers and clusters are hidden
            if (!markersVisible && !clustersVisible) {
                const stateNameMap = {
                    'JHR': 'Johor', 'KDH': 'Kedah', 'KTN': 'Kelantan', 'MLK': 'Melaka',
                    'NSN': 'Negeri Sembilan', 'PHG': 'Pahang', 'PRK': 'Perak', 'PLS': 'Perlis',
                    'PNG': 'Pulau Pinang', 'SBH': 'Sabah', 'SWK': 'Sarawak', 'SGR': 'Selangor',
                    'TRG': 'Terengganu', 'WPK': 'Wp Kuala Lumpur', 'WPL': 'Wp Labuan',
                    'WPP': 'Wp Putrajaya', 'KUL': 'Wp Kuala Lumpur', 'LBN': 'Wp Labuan', 'PJY': 'Wp Putrajaya'
                };

                const enterHandler = (e) => {
                    const props = e.features[0].properties;
                    const coordinates = e.lngLat;

                    const districtName = props.name || props.district || props.District || 'Unknown District';
                    let stateName = props.state || props.State || '';
                    if (stateName && stateName.length === 3 && stateName.toUpperCase() === stateName) {
                        stateName = stateNameMap[stateName] || stateName;
                    }

                    const formatValue = (value) => {
                        if (value === null || value === undefined || isNaN(value)) {
                            return 'N/A';
                        }
                        if (typeof value === 'number') {
                            return value.toLocaleString('en-US', { 
                                maximumFractionDigits: value < 1 ? 2 : 0 
                            });
                        }
                        return value;
                    };

                    const population = formatValue(props.population_k);
                    const incomePC = formatValue(props.income_pc);
                    const incomeTotal = formatValue(props.income_total);

                    const html = `
                        <div style="font-weight: bold; font-size: 13px; margin-bottom: 6px; color: #333;">
                            ${districtName}${stateName ? `, ${stateName}` : ''}
                        </div>
                        <div style="font-size: 11px; line-height: 1.5;">
                            <div style="margin-bottom: 3px;">
                                <strong>Population:</strong> ${population}${typeof props.population_k === 'number' ? 'k' : ''}
                            </div>
                            <div style="margin-bottom: 3px;">
                                <strong>Income per capita:</strong> ${incomePC}${typeof props.income_pc === 'number' ? ' RM' : ''}
                            </div>
                            <div>
                                <strong>Total Income:</strong> ${incomeTotal}${typeof props.income_total === 'number' ? ' RM' : ''}
                            </div>
                        </div>
                    `;

                    // Remove existing tooltip
                    if (districtHoverTooltip) {
                        districtHoverTooltip.remove();
                    }

                    // Create hover tooltip
                    districtHoverTooltip = new mapboxgl.Popup({
                        closeButton: false,
                        closeOnClick: false,
                        closeOnMove: false,
                        className: 'district-hover-tooltip',
                        anchor: 'top'
                    })
                        .setLngLat(coordinates)
                        .setHTML(html)
                        .addTo(map);
                };

                const leaveHandler = () => {
                    if (districtHoverTooltip) {
                        districtHoverTooltip.remove();
                        districtHoverTooltip = null;
                    }
                };

                map.on('mouseenter', 'district-fills', enterHandler);
                map.on('mouseleave', 'district-fills', leaveHandler);
                
                // Store handlers for later removal
                districtHoverTooltipHandler = {
                    enter: enterHandler,
                    leave: leaveHandler
                };
            }
        }


        function updateClusterVisibility(enabled) {
            const clusterVisibility = enabled ? 'visible' : 'none';
            const unclVisibility = enabled ? 'none' : 'visible';

            // Handle convenience stores mode
            if (currentIndustry === 'Convenience Stores') {
                if (map.getLayer('convenience-clusters')) {
                    map.setLayoutProperty('convenience-clusters', 'visibility', clusterVisibility);
                }
                if (map.getLayer('convenience-cluster-count')) {
                    map.setLayoutProperty('convenience-cluster-count', 'visibility', clusterVisibility);
                }
                if (map.getLayer('convenience-points')) {
                    map.setLayoutProperty('convenience-points', 'visibility', unclVisibility);
                }
                if (map.getLayer('convenience-stores-nocluster-layer')) {
                    map.setLayoutProperty('convenience-stores-nocluster-layer', 'visibility', unclVisibility);
                }
                
                // Reorder layers to ensure convenience stores are above districts after visibility change
                setTimeout(() => {
                    try {
                        let targetLayer = null;
                        if (enabled && map.getLayer('convenience-clusters')) {
                            targetLayer = 'convenience-clusters';
                        } else if (enabled && map.getLayer('convenience-cluster-count')) {
                            targetLayer = 'convenience-cluster-count';
                        } else if (!enabled && map.getLayer('convenience-stores-nocluster-layer')) {
                            targetLayer = 'convenience-stores-nocluster-layer';
                        } else if (!enabled && map.getLayer('convenience-points')) {
                            targetLayer = 'convenience-points';
                        }
                        
                        if (targetLayer && map.getLayer('district-borders')) {
                            map.moveLayer('district-borders', targetLayer);
                        }
                        if (targetLayer && map.getLayer('district-fills')) {
                            map.moveLayer('district-fills', targetLayer);
                        }
                    } catch (e) {
                        console.warn('Could not reorder layers after cluster toggle:', e);
                    }
                }, 100);
            } else if (currentIndustry === 'Gold Shops') {
                // Handle gold shops mode
                if (map.getLayer('goldshops-clusters')) {
                    map.setLayoutProperty('goldshops-clusters', 'visibility', clusterVisibility);
                }
                if (map.getLayer('goldshops-cluster-count')) {
                    map.setLayoutProperty('goldshops-cluster-count', 'visibility', clusterVisibility);
                }
                if (map.getLayer('goldshops-points')) {
                    map.setLayoutProperty('goldshops-points', 'visibility', unclVisibility);
                }
                if (map.getLayer('goldshops-nocluster-layer')) {
                    map.setLayoutProperty('goldshops-nocluster-layer', 'visibility', unclVisibility);
                }
                
                // Reorder layers to ensure gold shops are above districts after visibility change
                setTimeout(() => {
                    try {
                        let targetLayer = null;
                        if (enabled && map.getLayer('goldshops-clusters')) {
                            targetLayer = 'goldshops-clusters';
                        } else if (enabled && map.getLayer('goldshops-cluster-count')) {
                            targetLayer = 'goldshops-cluster-count';
                        } else if (!enabled && map.getLayer('goldshops-nocluster-layer')) {
                            targetLayer = 'goldshops-nocluster-layer';
                        } else if (!enabled && map.getLayer('goldshops-points')) {
                            targetLayer = 'goldshops-points';
                        }
                        
                        if (targetLayer && map.getLayer('district-borders')) {
                            map.moveLayer('district-borders', targetLayer);
                        }
                        if (targetLayer && map.getLayer('district-fills')) {
                            map.moveLayer('district-fills', targetLayer);
                        }
                    } catch (e) {
                        console.warn('Could not reorder layers after cluster toggle:', e);
                    }
                }, 100);
            } else if (currentIndustry === 'Department Stores') {
                // Handle department stores mode
                if (map.getLayer('departmentstores-clusters')) {
                    map.setLayoutProperty('departmentstores-clusters', 'visibility', clusterVisibility);
                }
                if (map.getLayer('departmentstores-cluster-count')) {
                    map.setLayoutProperty('departmentstores-cluster-count', 'visibility', clusterVisibility);
                }
                if (map.getLayer('departmentstores-points')) {
                    map.setLayoutProperty('departmentstores-points', 'visibility', unclVisibility);
                }
                if (map.getLayer('departmentstores-nocluster-layer')) {
                    map.setLayoutProperty('departmentstores-nocluster-layer', 'visibility', unclVisibility);
                }
                
                // Reorder layers to ensure department stores are above districts after visibility change
                setTimeout(() => {
                    try {
                        let targetLayer = null;
                        if (enabled && map.getLayer('departmentstores-clusters')) {
                            targetLayer = 'departmentstores-clusters';
                        } else if (enabled && map.getLayer('departmentstores-cluster-count')) {
                            targetLayer = 'departmentstores-cluster-count';
                        } else if (!enabled && map.getLayer('departmentstores-nocluster-layer')) {
                            targetLayer = 'departmentstores-nocluster-layer';
                        } else if (!enabled && map.getLayer('departmentstores-points')) {
                            targetLayer = 'departmentstores-points';
                        }
                        
                        if (targetLayer && map.getLayer('district-borders')) {
                            map.moveLayer('district-borders', targetLayer);
                        }
                        if (targetLayer && map.getLayer('district-fills')) {
                            map.moveLayer('district-fills', targetLayer);
                        }
                    } catch (e) {
                        console.warn('Could not reorder layers after cluster toggle:', e);
                    }
                }, 100);
            } else if (currentIndustry === 'Fast Fashion') {
                // Handle fast fashion mode
                if (map.getLayer('fastfashion-clusters')) {
                    map.setLayoutProperty('fastfashion-clusters', 'visibility', clusterVisibility);
                }
                if (map.getLayer('fastfashion-cluster-count')) {
                    map.setLayoutProperty('fastfashion-cluster-count', 'visibility', clusterVisibility);
                }
                if (map.getLayer('fastfashion-points')) {
                    map.setLayoutProperty('fastfashion-points', 'visibility', unclVisibility);
                }
                if (map.getLayer('fastfashion-nocluster-layer')) {
                    map.setLayoutProperty('fastfashion-nocluster-layer', 'visibility', unclVisibility);
                }
                
                // Reorder layers to ensure fast fashion are above districts after visibility change
                setTimeout(() => {
                    try {
                        let targetLayer = null;
                        if (enabled && map.getLayer('fastfashion-clusters')) {
                            targetLayer = 'fastfashion-clusters';
                        } else if (enabled && map.getLayer('fastfashion-cluster-count')) {
                            targetLayer = 'fastfashion-cluster-count';
                        } else if (!enabled && map.getLayer('fastfashion-nocluster-layer')) {
                            targetLayer = 'fastfashion-nocluster-layer';
                        } else if (!enabled && map.getLayer('fastfashion-points')) {
                            targetLayer = 'fastfashion-points';
                        }
                        
                        if (targetLayer && map.getLayer('district-borders')) {
                            map.moveLayer('district-borders', targetLayer);
                        }
                        if (targetLayer && map.getLayer('district-fills')) {
                            map.moveLayer('district-fills', targetLayer);
                        }
                    } catch (e) {
                        console.warn('Could not reorder layers after cluster toggle:', e);
                    }
                }, 100);
            } else {
                // Normal mode
                if (map.getLayer('clusters')) {
                    map.setLayoutProperty('clusters', 'visibility', clusterVisibility);
                }
                if (map.getLayer('cluster-count')) {
                    map.setLayoutProperty('cluster-count', 'visibility', clusterVisibility);
                }
                if (map.getLayer('unclustered-point')) {
                    map.setLayoutProperty('unclustered-point', 'visibility', clusterVisibility);
                }
                if (map.getLayer('stores-nocluster-layer')) {
                    map.setLayoutProperty('stores-nocluster-layer', 'visibility', unclVisibility);
                }
                
                // Reorder layers to ensure normal stores are above districts after visibility change
                setTimeout(() => {
                    try {
                        let targetLayer = null;
                        if (enabled && map.getLayer('clusters')) {
                            targetLayer = 'clusters';
                        } else if (enabled && map.getLayer('cluster-count')) {
                            targetLayer = 'cluster-count';
                        } else if (!enabled && map.getLayer('stores-nocluster-layer')) {
                            targetLayer = 'stores-nocluster-layer';
                        } else if (!enabled && map.getLayer('unclustered-point')) {
                            targetLayer = 'unclustered-point';
                        }
                        
                        if (targetLayer && map.getLayer('district-borders')) {
                            map.moveLayer('district-borders', targetLayer);
                        }
                        if (targetLayer && map.getLayer('district-fills')) {
                            map.moveLayer('district-fills', targetLayer);
                        }
                        // Ensure borders are visible after layer reordering
                        ensureDistrictBordersVisible();
                    } catch (e) {
                        console.warn('Could not reorder layers after cluster toggle:', e);
                    }
                }, 100);
            }
            // Ensure borders are visible after all changes
            ensureDistrictBordersVisible();
        }

        function updateMarkersVisibility(visible) {
            const visibility = visible ? 'visible' : 'none';
            
            // Convenience stores layers
            if (map.getLayer('convenience-clusters')) {
                map.setLayoutProperty('convenience-clusters', 'visibility', visibility);
            }
            if (map.getLayer('convenience-cluster-count')) {
                map.setLayoutProperty('convenience-cluster-count', 'visibility', visibility);
            }
            if (map.getLayer('convenience-points')) {
                map.setLayoutProperty('convenience-points', 'visibility', visibility);
            }
            if (map.getLayer('convenience-stores-nocluster-layer')) {
                map.setLayoutProperty('convenience-stores-nocluster-layer', 'visibility', visibility);
            }
            
            // Gold shops layers
            if (map.getLayer('goldshops-clusters')) {
                map.setLayoutProperty('goldshops-clusters', 'visibility', visibility);
            }
            if (map.getLayer('goldshops-cluster-count')) {
                map.setLayoutProperty('goldshops-cluster-count', 'visibility', visibility);
            }
            if (map.getLayer('goldshops-points')) {
                map.setLayoutProperty('goldshops-points', 'visibility', visibility);
            }
            if (map.getLayer('goldshops-nocluster-layer')) {
                map.setLayoutProperty('goldshops-nocluster-layer', 'visibility', visibility);
            }
            
            // Department stores layers
            if (map.getLayer('departmentstores-clusters')) {
                map.setLayoutProperty('departmentstores-clusters', 'visibility', visibility);
            }
            if (map.getLayer('departmentstores-cluster-count')) {
                map.setLayoutProperty('departmentstores-cluster-count', 'visibility', visibility);
            }
            if (map.getLayer('departmentstores-points')) {
                map.setLayoutProperty('departmentstores-points', 'visibility', visibility);
            }
            if (map.getLayer('departmentstores-nocluster-layer')) {
                map.setLayoutProperty('departmentstores-nocluster-layer', 'visibility', visibility);
            }
            
            // Fast fashion layers
            if (map.getLayer('fastfashion-clusters')) {
                map.setLayoutProperty('fastfashion-clusters', 'visibility', visibility);
            }
            if (map.getLayer('fastfashion-cluster-count')) {
                map.setLayoutProperty('fastfashion-cluster-count', 'visibility', visibility);
            }
            if (map.getLayer('fastfashion-points')) {
                map.setLayoutProperty('fastfashion-points', 'visibility', visibility);
            }
            if (map.getLayer('fastfashion-nocluster-layer')) {
                map.setLayoutProperty('fastfashion-nocluster-layer', 'visibility', visibility);
            }
            
            // Normal mode layers (for other categories)
            if (map.getLayer('clusters')) {
                map.setLayoutProperty('clusters', 'visibility', visibility);
            }
            if (map.getLayer('cluster-count')) {
                map.setLayoutProperty('cluster-count', 'visibility', visibility);
            }
            if (map.getLayer('unclustered-point')) {
                map.setLayoutProperty('unclustered-point', 'visibility', visibility);
            }
            if (map.getLayer('stores-nocluster-layer')) {
                map.setLayoutProperty('stores-nocluster-layer', 'visibility', visibility);
            }
            
            // Keep floating legend always visible
            const legendContainer = document.getElementById('floating-legend');
            if (legendContainer) {
                legendContainer.style.display = 'block';
            }
            
            // Ensure district borders are visible
            ensureDistrictBordersVisible();
        }

        async function loadTabContent(tabId) {
            const panel = document.getElementById(tabId);
            
            switch(tabId) {
                case 'overview':
                    await loadOverview(panel);
                    break;
                case 'locations':
                    loadLocations(panel);
                    break;
                case 'analytics':
                    await loadAnalytics(panel);
                    break;
                case 'mpi':
                    await loadMPI(panel);
                    break;
            }
        }

        // State normalization function to fix duplicate counts
        // Load Market Power Index tab with analytics
        async function loadMPI(panel) {
            const mpiStats = getMPIStatistics();
            
            if (!mpiStats) {
                panel.innerHTML = '<div class="error" style="padding: 20px; text-align: center; color: #999;">Market Power Index data not available. Please ensure stores are loaded and a category is selected.</div>';
                return;
            }
            
            const industryLabel = currentIndustry || 'All Categories';
            
            panel.innerHTML = `
                <h3 style="color: #ff0000; margin-bottom: 20px; font-weight: 600;">Market Power Index - ${industryLabel}</h3>
                
                <!-- Explanation Box -->
                <div style="background: #fff3cd; padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                    <h4 style="margin: 0 0 8px 0; color: #856404; font-size: 14px;">What is Market Power Index?</h4>
                    <p style="margin: 0; font-size: 13px; line-height: 1.6; color: #856404;">
                        The Market Power Index measures the purchasing power available per store in each district.
                        <br><strong>Formula:</strong> (Population × Income per capita) ÷ Number of Stores
                        <br><br>
                        <strong>Higher MPI</strong> = More purchasing power per store = Potentially underserved market with expansion opportunities
                        <br><strong>Lower MPI</strong> = Less purchasing power per store = More competition or market saturation
                    </p>
                </div>
                
                <!-- Summary Statistics -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 25px;">
                    <div style="background: #d4edda; padding: 16px; border-radius: 8px; border: 1px solid #c3e6cb;">
                        <div style="font-size: 11px; color: #155724; margin-bottom: 4px; font-weight: 600;">Highest MPI</div>
                        <div style="font-size: 24px; font-weight: 700; color: #155724;">${Math.round(mpiStats.highest.mpi).toLocaleString()}</div>
                        <div style="font-size: 11px; color: #155724; margin-top: 4px;">${mpiStats.highest.name}</div>
                        <div style="font-size: 10px; color: #155724; margin-top: 2px;">${mpiStats.highest.stores} store(s)</div>
                    </div>
                    <div style="background: #f8d7da; padding: 16px; border-radius: 8px; border: 1px solid #f5c6cb;">
                        <div style="font-size: 11px; color: #721c24; margin-bottom: 4px; font-weight: 600;">Lowest MPI</div>
                        <div style="font-size: 24px; font-weight: 700; color: #721c24;">${Math.round(mpiStats.lowest.mpi).toLocaleString()}</div>
                        <div style="font-size: 11px; color: #721c24; margin-top: 4px;">${mpiStats.lowest.name}</div>
                        <div style="font-size: 10px; color: #721c24; margin-top: 2px;">${mpiStats.lowest.stores} store(s)</div>
                    </div>
                    <div style="background: #d1ecf1; padding: 16px; border-radius: 8px; border: 1px solid #bee5eb;">
                        <div style="font-size: 11px; color: #0c5460; margin-bottom: 4px; font-weight: 600;">Average MPI</div>
                        <div style="font-size: 24px; font-weight: 700; color: #0c5460;">${Math.round(mpiStats.average).toLocaleString()}</div>
                        <div style="font-size: 10px; color: #0c5460; margin-top: 4px;">${mpiStats.totalDistricts} districts with stores</div>
                    </div>
                </div>
                
                <!-- Top 10 Chart -->
                <div class="chart-container" style="margin-bottom: 25px;">
                    <canvas id="mpiTop10Chart"></canvas>
                </div>
                
                <!-- Bottom 10 Chart -->
                <div class="chart-container">
                    <canvas id="mpiBottom10Chart"></canvas>
                </div>
            `;
            
            // Create Top 10 chart
            const top10Ctx = document.getElementById('mpiTop10Chart').getContext('2d');
            new Chart(top10Ctx, {
                type: 'bar',
                data: {
                    labels: mpiStats.top10.map(d => d.name),
                    datasets: [{
                        label: 'Market Power Index',
                        data: mpiStats.top10.map(d => Math.round(d.mpi)),
                        backgroundColor: '#28a745',
                        borderColor: '#218838',
                        borderWidth: 1,
                        borderRadius: 4
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Top 10 Districts - Highest Market Power Index (Best Opportunities)',
                            font: { size: 14, weight: '600' },
                            color: '#000'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const district = mpiStats.top10[context.dataIndex];
                                    return [
                                        `MPI: ${Math.round(district.mpi).toLocaleString()}`,
                                        `Stores: ${district.stores}`,
                                        `Population: ${district.population}k`,
                                        `Income/capita: RM ${district.income.toLocaleString()}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#e0e0e0', drawBorder: false },
                            ticks: { color: '#666', font: { size: 11 } },
                            beginAtZero: true
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#666', font: { size: 11 } }
                        }
                    }
                }
            });
            
            // Create Bottom 10 chart
            const bottom10Ctx = document.getElementById('mpiBottom10Chart').getContext('2d');
            new Chart(bottom10Ctx, {
                type: 'bar',
                data: {
                    labels: mpiStats.bottom10.map(d => d.name),
                    datasets: [{
                        label: 'Market Power Index',
                        data: mpiStats.bottom10.map(d => Math.round(d.mpi)),
                        backgroundColor: '#dc3545',
                        borderColor: '#c82333',
                        borderWidth: 1,
                        borderRadius: 4
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Bottom 10 Districts - Lowest Market Power Index (High Competition)',
                            font: { size: 14, weight: '600' },
                            color: '#000'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const district = mpiStats.bottom10[context.dataIndex];
                                    return [
                                        `MPI: ${Math.round(district.mpi).toLocaleString()}`,
                                        `Stores: ${district.stores}`,
                                        `Population: ${district.population}k`,
                                        `Income/capita: RM ${district.income.toLocaleString()}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#e0e0e0', drawBorder: false },
                            ticks: { color: '#666', font: { size: 11 } },
                            beginAtZero: true
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#666', font: { size: 11 } }
                        }
                    }
                }
            });
        }

        function normalizeStateName(state) {
            if (!state || typeof state !== 'string') {
                return null;
            }
            
            // Trim whitespace
            const trimmed = state.trim();
            
            if (!trimmed || trimmed.toLowerCase() === 'unknown' || trimmed.toLowerCase() === 'nan') {
                return null;
            }
            
            // Valid Malaysian States (15 total)
            const validStates = {
                // 13 States
                'johor': 'Johor',
                'kedah': 'Kedah',
                'kelantan': 'Kelantan',
                'melaka': 'Melaka',
                'malacca': 'Melaka', // Common variation
                'negeri sembilan': 'Negeri Sembilan',
                'ns': 'Negeri Sembilan', // Abbreviation
                'pahang': 'Pahang',
                'perak': 'Perak',
                'perlis': 'Perlis',
                'pulau pinang': 'Pulau Pinang',
                'penang': 'Pulau Pinang', // Common variation
                'pp': 'Pulau Pinang', // Abbreviation
                'sabah': 'Sabah',
                'sarawak': 'Sarawak',
                'selangor': 'Selangor',
                'terengganu': 'Terengganu',
                // 3 Federal Territories
                'wp kuala lumpur': 'Wp Kuala Lumpur',
                'w.p. kuala lumpur': 'Wp Kuala Lumpur',
                'w.p kuala lumpur': 'Wp Kuala Lumpur',
                'wp. kuala lumpur': 'Wp Kuala Lumpur',
                'kuala lumpur': 'Wp Kuala Lumpur',
                'kl': 'Wp Kuala Lumpur', // Abbreviation
                'wp labuan': 'Wp Labuan',
                'w.p. labuan': 'Wp Labuan',
                'w.p labuan': 'Wp Labuan',
                'labuan': 'Wp Labuan',
                'wp putrajaya': 'Wp Putrajaya',
                'w.p. putrajaya': 'Wp Putrajaya',
                'w.p putrajaya': 'Wp Putrajaya',
                'putrajaya': 'Wp Putrajaya'
            };
            
            // Try exact match (case-insensitive)
            const lowerKey = trimmed.toLowerCase();
            if (validStates[lowerKey]) {
                return validStates[lowerKey];
            }
            
            // Try partial match for variations with extra spaces or formatting
            for (const [key, value] of Object.entries(validStates)) {
                // Remove all spaces and compare
                const normalizedKey = key.replace(/\s+/g, '').toLowerCase();
                const normalizedTrimmed = trimmed.replace(/\s+/g, '').toLowerCase();
                
                if (normalizedKey === normalizedTrimmed) {
                    return value;
                }
                
                // Also check if trimmed contains the key or vice versa (for partial matches)
                if (normalizedTrimmed.includes(normalizedKey) || normalizedKey.includes(normalizedTrimmed)) {
                    if (normalizedKey.length >= 4) { // Require at least 4 chars to avoid false matches
                        return value;
                    }
                }
            }
            
            // If no match found, return null (invalid state)
            return null;
        }

        async function loadOverview(panel) {
            try {
                // Use visibleLocations (filtered by current industry) instead of all data
                const dataToAnalyze = (visibleLocations && visibleLocations.length > 0) ? visibleLocations : locationsData;
                
                // Calculate statistics from the filtered data
                const citiesCount = {};
                const statesCount = {};
                const brandsCount = {};
                
                dataToAnalyze.forEach(feature => {
                    const props = feature.properties;
                    // Use sub_district if available, otherwise use city
                    const city = props.sub_district || props.city || 'Unknown';
                    const rawState = props.state || '';
                    const normalizedState = normalizeStateName(rawState);
                    const brand = props.brand || 'Unknown';
                    
                    citiesCount[city] = (citiesCount[city] || 0) + 1;
                    // Only count valid normalized states
                    if (normalizedState) {
                        statesCount[normalizedState] = (statesCount[normalizedState] || 0) + 1;
                    }
                    brandsCount[brand] = (brandsCount[brand] || 0) + 1;
                });
                
                // Calculate actual district count based on GeoJSON boundaries
                const districtCount = countDistrictsWithStores(dataToAnalyze);
                
                // Update summary stats
                document.getElementById('total-locations').textContent = dataToAnalyze.length;
                document.getElementById('total-cities').textContent = districtCount;
                
                // Sort by count (descending)
                const sortedCities = Object.entries(citiesCount)
                    .sort((a, b) => b[1] - a[1]);
                const sortedStates = Object.entries(statesCount)
                    .sort((a, b) => b[1] - a[1]);
                const sortedBrands = Object.entries(brandsCount)
                    .sort((a, b) => b[1] - a[1]);
                
                const industryLabel = currentIndustry || 'All Industries';
                
                panel.innerHTML = `
                    <h3 style="color: #ff0000; margin-bottom: 20px; font-weight: 600;">Overview - ${industryLabel}</h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 25px;">
                        <div style="background: #f8f8f8; padding: 16px; border-radius: 8px; border: 1px solid #e0e0e0; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 6px;">Total Stores</div>
                            <div style="font-size: 28px; font-weight: 700; color: #ff0000;">${dataToAnalyze.length}</div>
                        </div>
                        <div style="background: #f8f8f8; padding: 16px; border-radius: 8px; border: 1px solid #e0e0e0; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 6px;">Districts</div>
                            <div style="font-size: 28px; font-weight: 700; color: #ff0000;">${districtCount}</div>
                        </div>
                        <div style="background: #f8f8f8; padding: 16px; border-radius: 8px; border: 1px solid #e0e0e0; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 6px;">States</div>
                            <div style="font-size: 28px; font-weight: 700; color: #ff0000;">${Object.keys(statesCount).length}</div>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <canvas id="overviewStatesChart"></canvas>
                    </div>
                    
                    <div class="chart-container">
                        <canvas id="overviewDistrictsChart"></canvas>
                    </div>
                    
                    <div style="margin-top: 25px; padding: 16px; background: #f8f8f8; border-radius: 8px;">
                        <h4 style="margin-bottom: 12px; color: #333; font-weight: 600;">Top 10 Districts</h4>
                        <div style="max-height: 300px; overflow-y: auto;">
                            ${sortedCities.slice(0, 10).length > 0 ? sortedCities.slice(0, 10).map(([city, count], idx) => 
                                `<div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #e0e0e0; background: white; margin-bottom: 4px; border-radius: 4px;">
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <span style="font-weight: 600; color: #666; min-width: 24px; text-align: center;">${idx + 1}.</span>
                                        <span style="font-weight: 500;">${city}</span>
                                    </div>
                                    <span style="color: #ff0000; font-weight: 700; font-size: 16px;">${count}</span>
                                </div>`
                            ).join('') : '<div style="padding: 8px 0; color: #999;">No data available</div>'}
                        </div>
                    </div>
                `;
                
                // Create states chart
                if (sortedStates.length > 0) {
                    const statesCtx = document.getElementById('overviewStatesChart').getContext('2d');
                    new Chart(statesCtx, {
                        type: 'bar',
                        data: {
                            labels: sortedStates.map(([state]) => state),
                            datasets: [{
                                label: 'Stores',
                                data: sortedStates.map(([, count]) => count),
                                backgroundColor: '#ff0000',
                                borderColor: '#cc0000',
                                borderWidth: 1,
                                borderRadius: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: 'Stores by State',
                                    font: { size: 14, weight: '600' },
                                    color: '#000'
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 }, maxRotation: 45, minRotation: 45 }
                                },
                                y: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } },
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                } else {
                    document.getElementById('overviewStatesChart').parentElement.innerHTML = 
                        '<div style="text-align: center; padding: 40px; color: #999;">No state data available</div>';
                }
                
                // Create districts chart (top 15)
                if (sortedCities.length > 0) {
                    const topDistricts = sortedCities.slice(0, 15);
                    const districtsCtx = document.getElementById('overviewDistrictsChart').getContext('2d');
                    new Chart(districtsCtx, {
                        type: 'bar',
                        data: {
                            labels: topDistricts.map(([city]) => city),
                            datasets: [{
                                label: 'Stores',
                                data: topDistricts.map(([, count]) => count),
                                backgroundColor: '#ff6666',
                                borderColor: '#cc0000',
                                borderWidth: 1,
                                borderRadius: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: 'Top 15 Districts by Store Count',
                                    font: { size: 14, weight: '600' },
                                    color: '#000'
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 10 }, maxRotation: 45, minRotation: 45 }
                                },
                                y: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } },
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                } else {
                    document.getElementById('overviewDistrictsChart').parentElement.innerHTML = 
                        '<div style="text-align: center; padding: 40px; color: #999;">No district data available</div>';
                }
                
            } catch (error) {
                console.error('Error loading overview:', error);
                panel.innerHTML = '<div class="error">Error loading overview</div>';
            }
        }

        function loadLocations(panel) {
            const dataToUse = (visibleLocations && visibleLocations.length) ? visibleLocations : locationsData;
            const sortedLocations = [...dataToUse].sort((a, b) => 
                a.properties.store_name.localeCompare(b.properties.store_name)
            );
            
            panel.innerHTML = `
                <h3 style="color: #ff0000; margin-bottom: 15px;">Stores (${sortedLocations.length})</h3>
                <input type="text" id="store-search" placeholder="Search stores..." 
                    style="width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #e0e0e0; border-radius: 4px;">
                <div class="location-list" id="location-list">
                    ${sortedLocations.map(store => `
                        <div class="location-item" data-id="${store.properties.id}" 
                            onclick="selectStore(${store.properties.id})">
                            <div class="location-name">
                                ${store.properties.store_code} - ${store.properties.store_name}
                            </div>
                            <div class="location-address">${store.properties.address}</div>
                            <div class="location-city">
                                ${store.properties.sub_district ? `<strong>${store.properties.sub_district}</strong>, ${store.properties.state}${store.properties.original_city && store.properties.original_city !== store.properties.sub_district ? ` <span style="color:#999;font-size:11px;">(${store.properties.original_city})</span>` : ''}` : `${store.properties.city}, ${store.properties.state}`}
                                ${store.properties.brand ? ` · ${store.properties.brand}` : ''}
                                ${store.properties.sector ? ` · ${store.properties.sector}` : ''}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            // Add search functionality
            document.getElementById('store-search').addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const filtered = sortedLocations.filter(store => 
                    store.properties.store_name.toLowerCase().includes(searchTerm) ||
                    store.properties.store_code.toLowerCase().includes(searchTerm) ||
                    store.properties.address.toLowerCase().includes(searchTerm) ||
                    store.properties.city.toLowerCase().includes(searchTerm) ||
                    (store.properties.sub_district && store.properties.sub_district.toLowerCase().includes(searchTerm)) ||
                    (store.properties.original_city && store.properties.original_city.toLowerCase().includes(searchTerm)) ||
                    store.properties.state.toLowerCase().includes(searchTerm)
                );
                
                document.getElementById('location-list').innerHTML = filtered.map(store => `
                    <div class="location-item" data-id="${store.properties.id}" 
                        onclick="selectStore(${store.properties.id})">
                        <div class="location-name">
                            ${store.properties.store_code} - ${store.properties.store_name}
                        </div>
                        <div class="location-address">${store.properties.address}</div>
                        <div class="location-city">
                            ${store.properties.sub_district ? `<strong>${store.properties.sub_district}</strong>, ${store.properties.state}${store.properties.original_city && store.properties.original_city !== store.properties.sub_district ? ` <span style="color:#999;font-size:11px;">(${store.properties.original_city})</span>` : ''}` : `${store.properties.city}, ${store.properties.state}`}
                            ${store.properties.brand ? ` · ${store.properties.brand}` : ''}
                            ${store.properties.sector ? ` · ${store.properties.sector}` : ''}
                        </div>
                    </div>
                `).join('');
            });
        }

        // Global toggle function for sidebar collapse (can be called inline)
        window.toggleHeaderCollapse = function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            const sidebar = document.getElementById('sidebar');
            const icon = document.getElementById('header-collapse-icon');
            
            if (!sidebar || !icon) {
                console.error('Sidebar elements not found');
                return false;
            }
            
            const isCollapsed = sidebar.classList.contains('collapsed');
            
            if (isCollapsed) {
                // Expand - restore full sidebar
                const savedWidth = localStorage.getItem('sidebarWidth');
                sidebar.style.width = (savedWidth && parseInt(savedWidth) >= 300 && parseInt(savedWidth) <= 800) ? savedWidth + 'px' : '400px';
                sidebar.classList.remove('collapsed');
                icon.textContent = '▼';
                icon.title = 'Collapse panel';
                localStorage.setItem('sidebarCollapsed', 'false');
            } else {
                // Collapse - shrink to small rectangle
                const currentWidth = parseInt(window.getComputedStyle(sidebar).width, 10);
                if (currentWidth > 60) {
                    localStorage.setItem('sidebarWidth', currentWidth.toString());
                }
                sidebar.classList.add('collapsed');
                sidebar.style.width = '60px';
                icon.textContent = '▶';
                icon.title = 'Expand panel';
                localStorage.setItem('sidebarCollapsed', 'true');
            }
            
            return false;
        };
        
        // Global toggle function for sidebar (can be called inline)
        window.toggleSidebarPanel = function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            const icon = document.getElementById('sidebar-minimize-icon');
            const side = document.getElementById('sidebar');
            const btn = document.getElementById('sidebar-minimize-btn');
            
            if (!icon || !side || !btn) {
                console.error('Sidebar elements not found');
                return false;
            }
            
            const isCollapsed = side.classList.contains('collapsed');
            
            if (isCollapsed) {
                // Expand
                side.classList.remove('collapsed');
                icon.textContent = '−';
                btn.title = 'Minimize';
                const savedWidth = localStorage.getItem('sidebarWidth');
                side.style.width = (savedWidth && parseInt(savedWidth) >= 300 && parseInt(savedWidth) <= 800) ? savedWidth + 'px' : '400px';
                localStorage.setItem('sidebarCollapsed', 'false');
            } else {
                // Collapse
                const currentWidth = parseInt(window.getComputedStyle(side).width, 10);
                if (currentWidth > 60) {
                    localStorage.setItem('sidebarWidth', currentWidth.toString());
                }
                side.classList.add('collapsed');
                icon.textContent = '+';
                btn.title = 'Expand';
                localStorage.setItem('sidebarCollapsed', 'true');
            }
            
            return false;
        };
        
        // Sidebar minimize/maximize functionality
        function setupSidebarMinimize() {
            const minimizeBtn = document.getElementById('sidebar-minimize-btn');
            const sidebar = document.getElementById('sidebar');
            const minimizeIcon = document.getElementById('sidebar-minimize-icon');
            
            if (!minimizeBtn || !sidebar || !minimizeIcon) {
                console.warn('Sidebar minimize elements not found:', {
                    btn: !!minimizeBtn,
                    sidebar: !!sidebar,
                    icon: !!minimizeIcon
                });
                // Retry after a short delay
                setTimeout(setupSidebarMinimize, 200);
                return;
            }
            
            console.log('Setting up sidebar minimize button...');
            
            // Check if sidebar was collapsed on last session
            const wasCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
            if (wasCollapsed) {
                sidebar.classList.add('collapsed');
                minimizeIcon.textContent = '+';
                minimizeBtn.title = 'Expand';
            } else {
                minimizeIcon.textContent = '−';
                minimizeBtn.title = 'Minimize';
            }
            
            // Remove any existing onclick handlers
            minimizeBtn.onclick = null;
            
            // Add event listeners using the global function
            minimizeBtn.addEventListener('click', window.toggleSidebarPanel, true);
            minimizeBtn.addEventListener('mousedown', function(e) {
                e.stopPropagation();
            }, true);
            // onclick is already set inline in HTML, but set it here too as backup
            minimizeBtn.onclick = window.toggleSidebarPanel;
            
            // Make sure button is clickable
            minimizeBtn.style.pointerEvents = 'auto';
            minimizeBtn.style.cursor = 'pointer';
            
            console.log('Sidebar minimize button setup complete');
        }

        // Sidebar resize functionality
        function setupSidebarResize() {
            const sidebar = document.getElementById('sidebar');
            const resizeHandle = document.getElementById('sidebar-resize-handle');
            
            if (!sidebar || !resizeHandle) {
                console.warn('Sidebar resize elements not found');
                return;
            }
            
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            
            // Load saved width from localStorage
            const savedWidth = localStorage.getItem('sidebarWidth');
            if (savedWidth && !sidebar.classList.contains('collapsed')) {
                const width = parseInt(savedWidth);
                if (width >= 300 && width <= 800) {
                    sidebar.style.width = width + 'px';
                }
            }
            
            resizeHandle.addEventListener('mousedown', (e) => {
                // Don't allow resizing when collapsed
                if (sidebar.classList.contains('collapsed')) {
                    e.preventDefault();
                    return;
                }
                
                // Only handle if click is actually on the resize handle (left 6px)
                const rect = resizeHandle.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                
                // Only proceed if click is within the resize handle area (first 6px)
                if (clickX > 6) {
                    return; // Click is outside resize handle, let it propagate
                }
                
                isResizing = true;
                startX = e.clientX;
                startWidth = parseInt(window.getComputedStyle(sidebar).width, 10);
                resizeHandle.classList.add('dragging');
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const diff = startX - e.clientX; // Negative because sidebar is on the right
                const newWidth = startWidth + diff;
                
                // Constrain width between 300px and 800px
                const minWidth = 300;
                const maxWidth = 800;
                const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
                
                sidebar.style.width = constrainedWidth + 'px';
                sidebar.style.transition = 'none'; // Disable transition during resize
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    resizeHandle.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    
                    // Re-enable transition
                    sidebar.style.transition = 'width 0.1s ease, opacity 0.3s ease';
                    
                    // Save width to localStorage
                    const currentWidth = parseInt(window.getComputedStyle(sidebar).width, 10);
                    localStorage.setItem('sidebarWidth', currentWidth.toString());
                }
            });
            
            console.log('Sidebar resize functionality setup complete');
        }

        async function loadAnalytics(panel) {
            
            // Get the analytics content div
            const analyticsContent = document.getElementById('analytics-content');
            const contentPanel = analyticsContent || panel;
            
            try {
                // Use visibleLocations (filtered by current industry) instead of all data
                const dataToAnalyze = (visibleLocations && visibleLocations.length > 0) ? visibleLocations : locationsData;
                
                // Calculate statistics from the filtered data
                const citiesCount = {};
                const statesCount = {};
                const brandsCount = {};
                
                dataToAnalyze.forEach(feature => {
                    const props = feature.properties;
                    // Use sub_district if available, otherwise use city
                    const city = props.sub_district || props.city || 'Unknown';
                    const rawState = props.state || '';
                    const normalizedState = normalizeStateName(rawState);
                    const brand = props.brand || 'Unknown';
                    
                    citiesCount[city] = (citiesCount[city] || 0) + 1;
                    // Only count valid normalized states
                    if (normalizedState) {
                        statesCount[normalizedState] = (statesCount[normalizedState] || 0) + 1;
                    }
                    brandsCount[brand] = (brandsCount[brand] || 0) + 1;
                });
                
                // Calculate actual district count based on GeoJSON boundaries
                const districtCount = countDistrictsWithStores(dataToAnalyze);
                
                // Sort by count (descending)
                const sortedCities = Object.entries(citiesCount)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);
                const sortedStates = Object.entries(statesCount)
                    .sort((a, b) => b[1] - a[1]);
                const sortedBrands = Object.entries(brandsCount)
                    .sort((a, b) => b[1] - a[1]);
                
                const industryLabel = currentIndustry || 'All Industries';
                
                // Get categories for dropdown
                let categories = [];
                try {
                    const categoriesResponse = await fetch('/api/categories');
                    categories = await categoriesResponse.json();
                } catch (error) {
                    console.error('Error loading categories for analytics:', error);
                }
                
                contentPanel.innerHTML = `
                    <h3 style="margin-bottom: 20px; font-weight: 600; color: #ff0000;">Analytics - ${industryLabel}</h3>
                    <div style="margin-bottom: 16px; padding: 12px; background: #f8f8f8; border-radius: 8px; font-size: 13px;">
                        <div style="margin-bottom: 12px;">
                            <label for="industry-select-analytics" style="font-weight: 600; margin-right: 8px; color: #333; display: block; margin-bottom: 6px;">Industry:</label>
                            <select id="industry-select-analytics" class="industry-select" style="width: 100%; padding: 8px; border: 1px solid #e0e0e0; border-radius: 6px; background: white; font-size: 13px; cursor: pointer;">
                                ${categories.length > 0 ? categories.map(cat => 
                                    `<option value="${cat.category}" ${cat.category === currentIndustry ? 'selected' : ''}>${cat.category}</option>`
                                ).join('') : `
                                    <option value="Gold Shops" ${currentIndustry === 'Gold Shops' ? 'selected' : ''}>Gold Shops</option>
                                    <option value="Convenience Stores" ${currentIndustry === 'Convenience Stores' ? 'selected' : ''}>Convenience Stores</option>
                                    <option value="Department Stores" ${currentIndustry === 'Department Stores' ? 'selected' : ''}>Department Stores</option>
                                    <option value="Fast Fashion" ${currentIndustry === 'Fast Fashion' ? 'selected' : ''}>Fast Fashion</option>
                                `}
                            </select>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: #666;">Total Stores:</span>
                            <span style="font-weight: 600; color: #ff0000;">${dataToAnalyze.length}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: #666;">Districts:</span>
                            <span style="font-weight: 600;">${districtCount}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #666;">States:</span>
                            <span style="font-weight: 600;">${Object.keys(statesCount).length}</span>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="citiesChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="brandsChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="statesChart"></canvas>
                    </div>
                `;
                
                // Create cities chart
                if (sortedCities.length > 0) {
                    const citiesCtx = document.getElementById('citiesChart').getContext('2d');
                    new Chart(citiesCtx, {
                        type: 'bar',
                        data: {
                            labels: sortedCities.map(([city]) => city),
                            datasets: [{
                                label: 'Stores',
                                data: sortedCities.map(([, count]) => count),
                                backgroundColor: '#ff0000',
                                borderColor: '#cc0000',
                                borderWidth: 1,
                                borderRadius: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: 'Top Districts by Store Count',
                                    font: { size: 14, weight: '600' },
                                    color: '#000'
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } }
                                },
                                y: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } },
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                } else {
                    document.getElementById('citiesChart').parentElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">No district data available</div>';
                }
                
                // Create brands comparison chart
                if (sortedBrands.length > 0) {
                    const brandsCtx = document.getElementById('brandsChart').getContext('2d');
                    new Chart(brandsCtx, {
                        type: 'bar',
                        data: {
                            labels: sortedBrands.map(([brand]) => brand),
                            datasets: [{
                                label: 'Stores',
                                data: sortedBrands.map(([, count]) => count),
                                backgroundColor: sortedBrands.map(([brand]) => {
                                    // Get color from brandColors or use default
                                    const brandKey = brand.toLowerCase().replace(/\s+/g, '');
                                    return brandColors[brandKey] || '#ff6666';
                                }),
                                borderColor: '#cc0000',
                                borderWidth: 1,
                                borderRadius: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: 'Stores by Brand',
                                    font: { size: 14, weight: '600' },
                                    color: '#000'
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } }
                                },
                                y: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } },
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                } else {
                    document.getElementById('brandsChart').parentElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">No brand data available</div>';
                }
                
                // Create states chart
                if (sortedStates.length > 0) {
                    const statesCtx = document.getElementById('statesChart').getContext('2d');
                    new Chart(statesCtx, {
                        type: 'bar',
                        data: {
                            labels: sortedStates.map(([state]) => state),
                            datasets: [{
                                label: 'Stores',
                                data: sortedStates.map(([, count]) => count),
                                backgroundColor: '#ff6666',
                                borderColor: '#cc0000',
                                borderWidth: 1,
                                borderRadius: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: 'Stores by State',
                                    font: { size: 14, weight: '600' },
                                    color: '#000'
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } }
                                },
                                y: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } },
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                } else {
                    document.getElementById('statesChart').parentElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">No state data available</div>';
                }
                
                // ========== BRAND-SPECIFIC DISTANCE ANALYSIS ==========
                const brandDistanceStats = calculateBrandDistances(dataToAnalyze);
                
                // Prepare data for charts
                const brandAvgDistances = Object.entries(brandDistanceStats)
                    .map(([brand, stats]) => ({
                        brand: brand,
                        avgDistance: stats.avgDistance,
                        storeCount: stats.stores.length
                    }))
                    .filter(item => item.storeCount > 1) // Only brands with multiple stores
                    .sort((a, b) => b.avgDistance - a.avgDistance);
                
                // Create brand distance analytics HTML
                const brandDistanceHTML = `
                    <div style="margin-top: 30px; padding: 20px; background: #f8f8f8; border-radius: 8px;">
                        <h4 style="color: #ff0000; margin-bottom: 15px; font-weight: 600;">Brand-Specific Distance Analysis</h4>
                        
                        <div class="chart-container">
                            <canvas id="brandDistanceChart"></canvas>
                        </div>
                        
                        <div class="chart-container" style="max-height: 400px; overflow-y: auto;">
                            <canvas id="brandStateDistanceChart"></canvas>
                        </div>
                    </div>
                `;
                
                contentPanel.innerHTML += brandDistanceHTML;
                
                // Create brand average distance chart
                if (brandAvgDistances.length > 0) {
                    const brandDistCtx = document.getElementById('brandDistanceChart').getContext('2d');
                    new Chart(brandDistCtx, {
                        type: 'bar',
                        data: {
                            labels: brandAvgDistances.map(b => b.brand),
                            datasets: [{
                                label: 'Average Distance (km)',
                                data: brandAvgDistances.map(b => b.avgDistance),
                                backgroundColor: brandAvgDistances.map(b => {
                                    const brandKey = b.brand.toLowerCase().replace(/\s+/g, '');
                                    return brandColors[brandKey] || '#ff0000';
                                }),
                                borderColor: '#cc0000',
                                borderWidth: 1,
                                borderRadius: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: 'Average Distance Between Stores by Brand',
                                    font: { size: 14, weight: '600' },
                                    color: '#000'
                                },
                                tooltip: {
                                    callbacks: {
                                        afterLabel: function(context) {
                                            const brand = brandAvgDistances[context.dataIndex];
                                            return `Stores: ${brand.storeCount}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 }, maxRotation: 45, minRotation: 45 }
                                },
                                y: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } },
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Distance (km)',
                                        color: '#666'
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Create brand-state distance chart (grouped bar chart)
                const brandStateData = [];
                Object.entries(brandDistanceStats).forEach(([brand, stats]) => {
                    Object.entries(stats.stateStats).forEach(([state, stateData]) => {
                        if (stateData.storeCount > 1) {
                            brandStateData.push({
                                brand: brand,
                                state: state,
                                avgDistance: stateData.avgDistance,
                                storeCount: stateData.storeCount
                            });
                        }
                    });
                });
                
                if (brandStateData.length > 0) {
                    // Group by brand for better visualization
                    const brands = [...new Set(brandStateData.map(d => d.brand))];
                    const states = [...new Set(brandStateData.map(d => d.state))].sort();
                    
                    const datasets = brands.slice(0, 10).map((brand, idx) => {
                        const brandData = brandStateData.filter(d => d.brand === brand);
                        const data = states.map(state => {
                            const item = brandData.find(d => d.state === state);
                            return item ? item.avgDistance : null;
                        });
                        
                        const brandKey = brand.toLowerCase().replace(/\s+/g, '');
                        return {
                            label: brand,
                            data: data,
                            backgroundColor: brandColors[brandKey] || `hsl(${idx * 36}, 70%, 50%)`,
                            borderColor: '#cc0000',
                            borderWidth: 1,
                            borderRadius: 4
                        };
                    });
                    
                    const brandStateCtx = document.getElementById('brandStateDistanceChart').getContext('2d');
                    new Chart(brandStateCtx, {
                        type: 'bar',
                        data: {
                            labels: states,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { 
                                    display: true,
                                    position: 'right',
                                    labels: { boxWidth: 12, font: { size: 10 } }
                                },
                                title: {
                                    display: true,
                                    text: 'Average Distance Between Stores by Brand and State',
                                    font: { size: 14, weight: '600' },
                                    color: '#000'
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 10 }, maxRotation: 45, minRotation: 45 },
                                    stacked: false
                                },
                                y: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } },
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Distance (km)',
                                        color: '#666'
                                    }
                                }
                            }
                        }
                    });
                }
                
                // ========== CLUSTERING ANALYSIS ==========
                const clusteringHTML = `
                    <div style="margin-top: 30px; padding: 20px; background: #f8f8f8; border-radius: 8px;">
                        <h4 style="color: #ff0000; margin-bottom: 15px; font-weight: 600;">Store Clustering Analysis</h4>
                        <div style="margin-bottom: 15px; padding: 12px; background: white; border-radius: 6px; font-size: 13px;">
                            <label style="margin-right: 10px;">Cluster Radius (km):</label>
                            <input type="number" id="clusterEps" value="5" min="1" max="50" step="1" 
                                style="width: 80px; padding: 4px; border: 1px solid #e0e0e0; border-radius: 4px;">
                            <label style="margin-left: 15px; margin-right: 10px;">Min Stores:</label>
                            <input type="number" id="clusterMinPts" value="3" min="2" max="20" step="1"
                                style="width: 80px; padding: 4px; border: 1px solid #e0e0e0; border-radius: 4px;">
                            <button id="runClustering" style="margin-left: 15px; padding: 6px 16px; background: #ff0000; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                                Analyze Clusters
                            </button>
                        </div>
                        <div id="clusteringResults"></div>
                        <div class="chart-container">
                            <canvas id="clusteringChart"></canvas>
                        </div>
                    </div>
                `;
                
                contentPanel.innerHTML += clusteringHTML;
                
                // Clustering analysis function
                function runClusteringAnalysis() {
                    const eps = parseFloat(document.getElementById('clusterEps').value) || 5;
                    const minPts = parseInt(document.getElementById('clusterMinPts').value) || 3;
                    
                    const result = dbscan(dataToAnalyze, eps, minPts);
                    const clusters = result.clusters;
                    const noise = result.noise;
                    
                    // Calculate cluster statistics
                    const clusterStats = clusters.map((cluster, idx) => {
                        const clusterStores = cluster.map(i => dataToAnalyze[i]);
                        const brands = {};
                        const states = {};
                        
                        clusterStores.forEach(store => {
                            const brand = store.properties.brand || 'Unknown';
                            const state = store.properties.state || 'Unknown';
                            brands[brand] = (brands[brand] || 0) + 1;
                            states[state] = (states[state] || 0) + 1;
                        });
                        
                        // Calculate cluster center and radius
                        const coords = clusterStores.map(s => s.geometry.coordinates);
                        const avgLon = coords.reduce((sum, [lon]) => sum + lon, 0) / coords.length;
                        const avgLat = coords.reduce((sum, [, lat]) => sum + lat, 0) / coords.length;
                        
                        let maxRadius = 0;
                        coords.forEach(([lon, lat]) => {
                            const dist = calculateDistance(avgLat, avgLon, lat, lon);
                            if (dist > maxRadius) maxRadius = dist;
                        });
                        
                        return {
                            id: idx + 1,
                            size: cluster.length,
                            stores: clusterStores,
                            center: [avgLon, avgLat],
                            radius: maxRadius,
                            brands: brands,
                            states: states,
                            topBrand: Object.entries(brands).sort((a, b) => b[1] - a[1])[0]?.[0] || 'Mixed',
                            topState: Object.entries(states).sort((a, b) => b[1] - a[1])[0]?.[0] || 'Mixed'
                        };
                    });
                    
                    // Display results
                    const resultsDiv = document.getElementById('clusteringResults');
                    resultsDiv.innerHTML = `
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 20px;">
                            <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #e0e0e0;">
                                <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Total Clusters</div>
                                <div style="font-size: 20px; font-weight: 600; color: #ff0000;">${clusters.length}</div>
                            </div>
                            <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #e0e0e0;">
                                <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Stores in Clusters</div>
                                <div style="font-size: 20px; font-weight: 600; color: #ff0000;">${clusters.reduce((sum, c) => sum + c.length, 0)}</div>
                            </div>
                            <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #e0e0e0;">
                                <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Isolated Stores</div>
                                <div style="font-size: 20px; font-weight: 600; color: #ff0000;">${noise.length}</div>
                            </div>
                        </div>
                        <div style="max-height: 300px; overflow-y: auto; background: white; padding: 12px; border-radius: 6px; border: 1px solid #e0e0e0;">
                            <table style="width: 100%; font-size: 12px; border-collapse: collapse;">
                                <thead>
                                    <tr style="border-bottom: 2px solid #e0e0e0;">
                                        <th style="text-align: left; padding: 8px;">Cluster</th>
                                        <th style="text-align: left; padding: 8px;">Size</th>
                                        <th style="text-align: left; padding: 8px;">Top Brand</th>
                                        <th style="text-align: left; padding: 8px;">Top State</th>
                                        <th style="text-align: left; padding: 8px;">Radius (km)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${clusterStats.map(c => `
                                        <tr style="border-bottom: 1px solid #f0f0f0; cursor: pointer;" 
                                            onclick="highlightCluster(${c.id - 1})" 
                                            onmouseover="this.style.background='#f8f8f8'" 
                                            onmouseout="this.style.background='white'">
                                            <td style="padding: 8px; font-weight: 600; color: #ff0000;">Cluster ${c.id}</td>
                                            <td style="padding: 8px;">${c.size}</td>
                                            <td style="padding: 8px;">${c.topBrand}</td>
                                            <td style="padding: 8px;">${c.topState}</td>
                                            <td style="padding: 8px;">${c.radius.toFixed(2)}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    `;
                    
                    // Store cluster stats globally for map highlighting
                    window.clusterStats = clusterStats;
                    
                    // Create cluster size distribution chart
                    const clusterSizeBins = [2, 3, 5, 10, 20, 50];
                    const clusterSizeLabels = ['2', '3-4', '5-9', '10-19', '20-49', '50+'];
                    const clusterSizeCounts = new Array(clusterSizeBins.length).fill(0);
                    
                    clusterStats.forEach(c => {
                        for (let i = 0; i < clusterSizeBins.length; i++) {
                            if (c.size < clusterSizeBins[i]) {
                                clusterSizeCounts[i]++;
                                break;
                            }
                        }
                        if (c.size >= clusterSizeBins[clusterSizeBins.length - 1]) {
                            clusterSizeCounts[clusterSizeCounts.length - 1]++;
                        }
                    });
                    
                    const clusterCtx = document.getElementById('clusteringChart').getContext('2d');
                    if (window.clusteringChartInstance) {
                        window.clusteringChartInstance.destroy();
                    }
                    window.clusteringChartInstance = new Chart(clusterCtx, {
                        type: 'bar',
                        data: {
                            labels: clusterSizeLabels.map(l => l + ' stores'),
                            datasets: [{
                                label: 'Number of Clusters',
                                data: clusterSizeCounts,
                                backgroundColor: '#ff0000',
                                borderColor: '#cc0000',
                                borderWidth: 1,
                                borderRadius: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: 'Cluster Size Distribution',
                                    font: { size: 14, weight: '600' },
                                    color: '#000'
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } }
                                },
                                y: {
                                    grid: { color: '#e0e0e0', drawBorder: false },
                                    ticks: { color: '#666', font: { size: 11 } },
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
                
                // Attach clustering button handler
                const runClusteringBtn = document.getElementById('runClustering');
                if (runClusteringBtn) {
                    runClusteringBtn.addEventListener('click', runClusteringAnalysis);
                }
                // Run initial clustering
                setTimeout(() => {
                    if (document.getElementById('runClustering')) {
                        runClusteringAnalysis();
                    }
                }, 500);
                
                // ========== MARKET GAP ANALYSIS ==========
                const marketGapHTML = `
                    <div style="margin-top: 30px; padding: 20px; background: #f8f8f8; border-radius: 8px;">
                        <h4 style="color: #ff0000; margin-bottom: 15px; font-weight: 600;">Market Gap Analysis</h4>
                        <div style="margin-bottom: 15px; padding: 12px; background: white; border-radius: 6px; font-size: 13px;">
                            <label style="margin-right: 10px;">Min Distance from Store (km):</label>
                            <input type="number" id="gapMinDistance" value="10" min="1" max="50" step="1" 
                                style="width: 80px; padding: 4px; border: 1px solid #e0e0e0; border-radius: 4px;">
                            <label style="margin-left: 15px; margin-right: 10px;">Min Population (k):</label>
                            <input type="number" id="gapMinPopulation" value="50" min="0" max="1000" step="10"
                                style="width: 80px; padding: 4px; border: 1px solid #e0e0e0; border-radius: 4px;">
                            <label style="margin-left: 15px; margin-right: 10px;">Min Income per Capita:</label>
                            <input type="number" id="gapMinIncome" value="30000" min="0" max="200000" step="5000"
                                style="width: 100px; padding: 4px; border: 1px solid #e0e0e0; border-radius: 4px;">
                            <button id="runMarketGap" style="margin-left: 15px; padding: 6px 16px; background: #ff0000; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                                Find Market Gaps
                            </button>
                            <button id="animateGaps" style="margin-left: 10px; padding: 6px 16px; background: #ff6666; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                                Animate Gaps
                            </button>
                        </div>
                        <div id="marketGapResults"></div>
                    </div>
                `;
                
                contentPanel.innerHTML += marketGapHTML;
                
                // Market gap analysis function
                function runMarketGapAnalysis() {
                    const minDistance = parseFloat(document.getElementById('gapMinDistance').value) || 10;
                    const minPopulation = parseFloat(document.getElementById('gapMinPopulation').value) || 50;
                    const minIncome = parseFloat(document.getElementById('gapMinIncome').value) || 30000;
                    
                    if (!districtGeojson || !districtGeojson.features) {
                        document.getElementById('marketGapResults').innerHTML = 
                            '<div style="padding: 20px; color: #999;">District data not available</div>';
                        return;
                    }
                    
                    // Find districts that meet criteria and are far from stores
                    const gaps = [];
                    
                    districtGeojson.features.forEach(district => {
                        const props = district.properties;
                        const population = props.population_k || 0;
                        const income = props.income_pc || 0;
                        
                        // Check if district meets population/income criteria
                        if (population >= minPopulation && income >= minIncome) {
                            // Calculate center of district (simplified - use first coordinate)
                            const coords = district.geometry.coordinates;
                            let centerLon = 0, centerLat = 0, coordCount = 0;
                            
                            function extractCoords(coordArray) {
                                if (Array.isArray(coordArray[0][0])) {
                                    coordArray.forEach(polygon => extractCoords(polygon));
                                } else {
                                    coordArray.forEach(([lon, lat]) => {
                                        centerLon += lon;
                                        centerLat += lat;
                                        coordCount++;
                                    });
                                }
                            }
                            
                            extractCoords(coords);
                            if (coordCount > 0) {
                                centerLon /= coordCount;
                                centerLat /= coordCount;
                            }
                            
                            // Find nearest store
                            let minStoreDistance = Infinity;
                            dataToAnalyze.forEach(store => {
                                const [lon, lat] = store.geometry.coordinates;
                                const distance = calculateDistance(centerLat, centerLon, lat, lon);
                                if (distance < minStoreDistance) {
                                    minStoreDistance = distance;
                                }
                            });
                            
                            // If far enough from stores, it's a market gap
                            if (minStoreDistance >= minDistance) {
                                gaps.push({
                                    district: props.name || 'Unknown',
                                    state: props.state || 'Unknown',
                                    population: population,
                                    income: income,
                                    distance: minStoreDistance,
                                    center: [centerLon, centerLat]
                                });
                            }
                        }
                    });
                    
                    // Sort by opportunity score (population * income / distance)
                    gaps.sort((a, b) => {
                        const scoreA = (a.population * a.income) / (a.distance + 1);
                        const scoreB = (b.population * b.income) / (b.distance + 1);
                        return scoreB - scoreA;
                    });
                    
                    // Display results
                    const resultsDiv = document.getElementById('marketGapResults');
                    resultsDiv.innerHTML = `
                        <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #e0e0e0; margin-bottom: 15px;">
                            <div style="font-size: 14px; font-weight: 600; color: #ff0000; margin-bottom: 8px;">
                                Found ${gaps.length} Market Gap${gaps.length !== 1 ? 's' : ''}
                            </div>
                        </div>
                        <div style="max-height: 400px; overflow-y: auto; background: white; padding: 12px; border-radius: 6px; border: 1px solid #e0e0e0;">
                            <table style="width: 100%; font-size: 12px; border-collapse: collapse;">
                                <thead>
                                    <tr style="border-bottom: 2px solid #e0e0e0;">
                                        <th style="text-align: left; padding: 8px;">District</th>
                                        <th style="text-align: left; padding: 8px;">State</th>
                                        <th style="text-align: right; padding: 8px;">Population (k)</th>
                                        <th style="text-align: right; padding: 8px;">Income (pc)</th>
                                        <th style="text-align: right; padding: 8px;">Distance (km)</th>
                                        <th style="text-align: left; padding: 8px;">Action</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${gaps.slice(0, 50).map((gap, idx) => `
                                        <tr style="border-bottom: 1px solid #f0f0f0;">
                                            <td style="padding: 8px; font-weight: 600;">${gap.district}</td>
                                            <td style="padding: 8px;">${gap.state}</td>
                                            <td style="padding: 8px; text-align: right;">${gap.population.toFixed(1)}</td>
                                            <td style="padding: 8px; text-align: right;">${gap.income.toLocaleString()}</td>
                                            <td style="padding: 8px; text-align: right;">${gap.distance.toFixed(2)}</td>
                                            <td style="padding: 8px;">
                                                <button onclick="showMarketGap(${idx})" 
                                                    style="padding: 4px 12px; background: #ff0000; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                                                    View
                                                </button>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    `;
                    
                    // Store gaps globally
                    window.marketGaps = gaps;
                }
                
                // Attach event handlers
                const runMarketGapBtn = document.getElementById('runMarketGap');
                if (runMarketGapBtn) {
                    runMarketGapBtn.addEventListener('click', runMarketGapAnalysis);
                }
                const animateGapsBtn = document.getElementById('animateGaps');
                if (animateGapsBtn) {
                    animateGapsBtn.addEventListener('click', () => {
                        if (window.marketGaps && window.marketGaps.length > 0) {
                            window.animateAllGaps();
                        } else {
                            runMarketGapAnalysis();
                            setTimeout(() => window.animateAllGaps(), 500);
                        }
                    });
                }
                
                // Run initial market gap analysis
                setTimeout(() => {
                    if (document.getElementById('runMarketGap')) {
                        runMarketGapAnalysis();
                    }
                }, 1000);
                
                // Add event listener for analytics industry selector
                const analyticsIndustrySelect = document.getElementById('industry-select-analytics');
                if (analyticsIndustrySelect) {
                    // Remove any existing listeners by cloning the element
                    const newSelect = analyticsIndustrySelect.cloneNode(true);
                    analyticsIndustrySelect.parentNode.replaceChild(newSelect, analyticsIndustrySelect);
                    
                    newSelect.addEventListener('change', (e) => {
                        currentIndustry = e.target.value;
                        console.log('Industry changed from analytics panel to:', currentIndustry);
                        
                        // Sync with main data-select dropdown
                        const dataSelect = document.getElementById('data-select');
                        if (dataSelect) {
                            dataSelect.value = currentIndustry || '';
                        }
                        
                        applyIndustryFilter();
                        updateMapMarkers();
                        updateStats();
                        updateFloatingLegend();
                    });
                }
                
            } catch (error) {
                console.error('Error loading analytics:', error);
                contentPanel.innerHTML = '<div class="error">Error loading analytics</div>';
            }
        }

        // Function to highlight cluster on map
        window.highlightCluster = function(clusterId) {
            if (!window.clusterStats || !window.clusterStats[clusterId]) return;
            
            const cluster = window.clusterStats[clusterId];
            const [lon, lat] = cluster.center;
            
            // Fly to cluster center
            map.flyTo({
                center: [lon, lat],
                zoom: 12,
                duration: 1000
            });
            
            // Draw circle around cluster
            if (window.clusterCircle) {
                if (map.getLayer('cluster-circle-layer')) map.removeLayer('cluster-circle-layer');
                if (map.getLayer('cluster-circle-border')) map.removeLayer('cluster-circle-border');
                if (map.getSource('cluster-circle')) map.removeSource('cluster-circle');
            }
            
            const radiusKm = cluster.radius;
            
            // Create circle using Turf.js
            const circle = turf.circle([lon, lat], radiusKm, { steps: 64, units: 'kilometers' });
            
            if (map.getSource('cluster-circle')) {
                map.getSource('cluster-circle').setData(circle);
            } else {
                map.addSource('cluster-circle', {
                    type: 'geojson',
                    data: circle
                });
                
                map.addLayer({
                    id: 'cluster-circle-layer',
                    type: 'fill',
                    source: 'cluster-circle',
                    paint: {
                        'fill-color': '#ff0000',
                        'fill-opacity': 0.2
                    }
                });
                
                map.addLayer({
                    id: 'cluster-circle-border',
                    type: 'line',
                    source: 'cluster-circle',
                    paint: {
                        'line-color': '#ff0000',
                        'line-width': 2,
                        'line-opacity': 0.8
                    }
                });
            }
            
            window.clusterCircle = true;
        };

        // Function to show market gap on map with animated circle
        window.showMarketGap = function(gapIndex) {
            if (!window.marketGaps || !window.marketGaps[gapIndex]) return;
            
            const gap = window.marketGaps[gapIndex];
            const [lon, lat] = gap.center;
            
            // Fly to location
            map.flyTo({
                center: [lon, lat],
                zoom: 11,
                duration: 1500
            });
            
            // Remove existing gap circles
            if (window.gapCircles) {
                window.gapCircles.forEach(circle => {
                    if (map.getLayer(circle.layerId)) map.removeLayer(circle.layerId);
                    if (map.getLayer(circle.borderId)) map.removeLayer(circle.borderId);
                    if (map.getSource(circle.sourceId)) map.removeSource(circle.sourceId);
                });
            }
            window.gapCircles = [];
            
            // Create animated circle
            animateGapCircle([lon, lat], gap.distance);
        };

        // Animated circle function
        function animateGapCircle(center, maxRadius) {
            let currentRadius = 0;
            const maxRadiusKm = Math.min(maxRadius, 20); // Cap at 20km for visibility
            const animationDuration = 2000; // 2 seconds
            const steps = 60;
            const radiusStep = maxRadiusKm / steps;
            const timeStep = animationDuration / steps;
            
            // Remove existing animated circles
            if (window.animatedGapCircles) {
                window.animatedGapCircles.forEach(c => {
                    if (map.getLayer(c.layerId)) map.removeLayer(c.layerId);
                    if (map.getLayer(c.borderId)) map.removeLayer(c.borderId);
                    if (map.getSource(c.sourceId)) map.removeSource(c.sourceId);
                });
            }
            window.animatedGapCircles = [];
            
            let step = 0;
            const animate = () => {
                if (step >= steps) {
                    // Keep final circle
                    return;
                }
                
                currentRadius += radiusStep;
                const circle = turf.circle(center, currentRadius, { steps: 64, units: 'kilometers' });
                
                const sourceId = `gap-circle-${step}`;
                const layerId = `gap-circle-layer-${step}`;
                const borderId = `gap-circle-border-${step}`;
                
                if (map.getSource(sourceId)) {
                    map.getSource(sourceId).setData(circle);
                } else {
                    map.addSource(sourceId, {
                        type: 'geojson',
                        data: circle
                    });
                    
                    map.addLayer({
                        id: layerId,
                        type: 'fill',
                        source: sourceId,
                        paint: {
                            'fill-color': '#ff0000',
                            'fill-opacity': 0.15 * (1 - step / steps) // Fade out
                        }
                    });
                    
                    map.addLayer({
                        id: borderId,
                        type: 'line',
                        source: sourceId,
                        paint: {
                            'line-color': '#ff0000',
                            'line-width': 2,
                            'line-opacity': 0.6 * (1 - step / steps)
                        }
                    });
                    
                    window.animatedGapCircles.push({
                        sourceId: sourceId,
                        layerId: layerId,
                        borderId: borderId
                    });
                }
                
                step++;
                if (step < steps) {
                    setTimeout(animate, timeStep);
                }
            };
            
            animate();
        }

        // Function to animate all market gaps
        window.animateAllGaps = function() {
            if (!window.marketGaps || window.marketGaps.length === 0) {
                const runGapBtn = document.getElementById('runMarketGap');
                if (runGapBtn) {
                    runGapBtn.click();
                    setTimeout(() => window.animateAllGaps(), 500);
                }
                return;
            }
            
            let currentIndex = 0;
            const animateNext = () => {
                if (currentIndex >= window.marketGaps.length) {
                    currentIndex = 0; // Loop
                }
                
                const gap = window.marketGaps[currentIndex];
                const [lon, lat] = gap.center;
                
                // Fly to location
                map.flyTo({
                    center: [lon, lat],
                    zoom: 11,
                    duration: 1500
                });
                
                // Animate circle after fly completes
                setTimeout(() => {
                    animateGapCircle([lon, lat], gap.distance);
                    currentIndex++;
                    setTimeout(animateNext, 4000); // Wait 4 seconds before next gap
                }, 1600);
            };
            
            animateNext();
        };

        function selectStore(storeId) {
            // Remove previous selection
            document.querySelectorAll('.location-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Add selection to clicked item
            const item = document.querySelector(`[data-id="${storeId}"]`);
            if (item) item.classList.add('selected');
            
            // Find and focus on the store on the map
            const store = (visibleLocations && visibleLocations.length ? visibleLocations : locationsData)
                .find(loc => loc.properties.id === storeId);
            if (store) {
                map.flyTo({
                    center: store.geometry.coordinates,
                    zoom: 15
                });
                
                // Open popup
                new mapboxgl.Popup({ offset: 25 })
                    .setLngLat(store.geometry.coordinates)
                    .setHTML(`
                        <div class="popup-title">
                            ${store.properties.store_code} - ${store.properties.store_name}
                        </div>
                        <div class="popup-info">
                            <div>${store.properties.address}</div>
                            ${formatLocationDisplay(store.properties)}
                            <div style="margin-top:6px;font-size:12px;color:#999;">
                                ${store.properties.brand || ''}${store.properties.sector ? ` · ${store.properties.sector}` : ''}
                            </div>
                        </div>
                    `)
                    .addTo(map);
            }
        }



        function applyIndustryFilter() {
            if (!currentIndustry) {
                visibleLocations = [];
                convenienceStoreLocations = [];
                goldShopLocations = [];
                departmentStoreLocations = [];
                fastFashionLocations = [];
            } else {
                // Debug: Check what categories exist in the data
                const allCategories = [...new Set(locationsData.map(f => {
                    return {
                        category: (f.properties.category || '').trim(),
                        sector: (f.properties.sector || '').trim(),
                        brand: f.properties.brand
                    };
                }))];
                console.log('All categories in data:', allCategories);
                console.log('Looking for industry:', currentIndustry);
                
                // Find the actual category name that matches (case-insensitive, flexible matching)
                let matchingCategory = null;
                for (const cat of allCategories) {
                    const catName = (cat.category || cat.sector || '').trim();
                    const catLower = catName.toLowerCase();
                    const industryLower = currentIndustry.toLowerCase();
                    
                    if (catLower === industryLower || 
                        (catLower.includes('gold') && industryLower.includes('gold')) ||
                        (catLower.includes('convenience') && industryLower.includes('convenience')) ||
                        (catLower.includes('department') && industryLower.includes('department')) ||
                        (catLower.includes('fast') && industryLower.includes('fast') && catLower.includes('fashion') && industryLower.includes('fashion'))) {
                        matchingCategory = catName;
                        console.log('Found matching category:', matchingCategory, 'for industry:', currentIndustry);
                        break;
                    }
                }
                
                // If no match found, log all available categories for debugging
                if (!matchingCategory && currentIndustry) {
                    console.warn('No matching category found for:', currentIndustry);
                    console.warn('Available categories:', allCategories.map(c => (c.category || c.sector || '').trim()));
                }
                
                // Filter by category/industry - use the actual category name from data
                visibleLocations = locationsData.filter(f => {
                    const category = (f.properties.category || f.properties.sector || '').trim();
                    // Match exactly or use the found matching category
                    const matches = category === currentIndustry || 
                                   (matchingCategory && category === matchingCategory) ||
                                   (category.toLowerCase().includes('gold') && currentIndustry.toLowerCase().includes('gold')) ||
                                   (category.toLowerCase().includes('convenience') && currentIndustry.toLowerCase().includes('convenience')) ||
                                   (category.toLowerCase().includes('department') && currentIndustry.toLowerCase().includes('department')) ||
                                   (category.toLowerCase().includes('fast') && category.toLowerCase().includes('fashion') && currentIndustry.toLowerCase().includes('fast') && currentIndustry.toLowerCase().includes('fashion'));
                    return matches;
                });
                
                console.log('Filtering for industry:', currentIndustry);
                console.log('Found', visibleLocations.length, 'locations');
                if (visibleLocations.length > 0) {
                    console.log('Sample categories:', [...new Set(visibleLocations.slice(0, 5).map(f => (f.properties.category || f.properties.sector || '').trim()))]);
                }
                
                // Separate convenience stores, gold shops, department stores, and fast fashion for layer ordering
                convenienceStoreLocations = [];
                goldShopLocations = [];
                departmentStoreLocations = [];
                fastFashionLocations = [];
                if (currentIndustry === 'Convenience Stores') {
                    convenienceStoreLocations = visibleLocations;
                } else if (currentIndustry === 'Gold Shops') {
                    goldShopLocations = visibleLocations;
                } else if (currentIndustry === 'Department Stores') {
                    departmentStoreLocations = visibleLocations;
                } else if (currentIndustry === 'Fast Fashion') {
                    fastFashionLocations = visibleLocations;
                    
                    // Verification logging for Fast Fashion
                    const totalFastFashionInData = locationsData.filter(f => {
                        const category = (f.properties.category || f.properties.sector || '').trim();
                        return category.toLowerCase().includes('fast') && category.toLowerCase().includes('fashion');
                    }).length;
                    
                    console.log('=== FAST FASHION VERIFICATION ===');
                    console.log('Total Fast Fashion stores in all data:', totalFastFashionInData);
                    console.log('Fast Fashion stores after filtering (visibleLocations):', visibleLocations.length);
                    console.log('Fast Fashion stores assigned to fastFashionLocations:', fastFashionLocations.length);
                    console.log('Fast Fashion brands found:', [...new Set(visibleLocations.map(f => f.properties.brand))]);
                }
                
                console.log('Filtered to', visibleLocations.length, 'locations for', currentIndustry);
                if (visibleLocations.length > 0) {
                    console.log('Found brands:', [...new Set(visibleLocations.map(f => f.properties.brand))]);
                    console.log('Sample location:', visibleLocations[0]);
                } else {
                    console.warn('No locations found! Available categories:', 
                        [...new Set(locationsData.map(f => (f.properties.category || f.properties.sector || '').trim()))]);
                }
            }

            // Always update markers - even if empty array
            addMarkersToMap();
            updateFloatingLegend();
            
            // Reload active tab content with filtered data
            const activeTab = document.querySelector('.tab.active');
            if (activeTab) {
                const activeTabId = activeTab.getAttribute('data-tab');
                if (activeTabId === 'locations') {
                    loadLocations(document.getElementById('locations'));
                } else if (activeTabId === 'analytics') {
                    // Reload analytics with filtered data
                    loadAnalytics(document.getElementById('analytics'));
                } else if (activeTabId === 'overview') {
                    // Reload overview with filtered data
                    loadOverview(document.getElementById('overview'));
                }
            }
        }

        function updateFloatingLegend() {
            const legendContainer = document.getElementById('floating-legend');
            const legendItems = document.getElementById('floating-legend-items');
            
            if (!legendContainer || !legendItems) return;
            
            // Keep floating legend always visible
            legendContainer.style.display = 'block';
            
            if (!visibleLocations || visibleLocations.length === 0) {
                // Still show the legend even if no locations, just with empty content
                legendItems.innerHTML = '<div style="padding: 8px; color: #999; font-size: 12px;">No companies visible</div>';
                return;
            }
            
            // Get unique brands from visible locations
            const brandMap = new Map();
            visibleLocations.forEach(feature => {
                const brandKey = (feature.properties.brand_key || '').toLowerCase();
                const brandName = feature.properties.brand || 'Unknown';
                const color = feature.properties.color || brandColors[brandKey] || '#666666';
                
                if (!brandMap.has(brandKey)) {
                    brandMap.set(brandKey, {
                        name: brandName,
                        color: color,
                        count: 0
                    });
                }
                brandMap.get(brandKey).count++;
            });

            // Sort by brand name
            const sortedBrands = Array.from(brandMap.entries()).sort((a, b) => 
                a[1].name.localeCompare(b[1].name)
            );

            legendItems.innerHTML = sortedBrands.map(([key, info]) => `
                <div class="floating-legend-item">
                    <div class="floating-legend-color" style="background-color: ${info.color};"></div>
                    <div class="floating-legend-name">${info.name} (${info.count})</div>
                </div>
            `).join('');
        }


        // Initialize the application
        map.on('load', async () => {
            // Setup sidebar minimize button when map loads (with delay to ensure DOM is ready)
            setTimeout(() => {
                setupSidebarMinimize();
            }, 100);
            // Setup sidebar resize functionality
            setupSidebarResize();
            // Load data/layers
            await loadData();
            
            // Enforce layer order after data loads
            setTimeout(() => {
                maintainLayerOrder();
                console.log('✓ Initial layer order enforced');
            }, 200);

            const metricSelect = document.getElementById('metric-select');
            metricSelect.addEventListener('change', (e) => {
                const explanation = document.getElementById('metric-explanation');
                if (e.target.value === 'market_power_index') {
                    explanation.style.display = 'block';
                } else {
                    explanation.style.display = 'none';
                }
                updateDistrictChoropleth(e.target.value);
            });

            // Populate and setup data selection dropdown
            const dataSelect = document.getElementById('data-select');
            if (categories && categories.length > 0) {
                // Clear loading message
                dataSelect.innerHTML = '';
                
                // Add "All Categories" option
                const allOption = document.createElement('option');
                allOption.value = '';
                allOption.textContent = 'All Categories';
                dataSelect.appendChild(allOption);
                
                // Add each category as an option
                categories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat.category;
                    option.textContent = cat.category;
                    dataSelect.appendChild(option);
                });
                
                // Set the dropdown value to match currentIndustry (set in loadData)
                if (currentIndustry) {
                    dataSelect.value = currentIndustry;
                } else if (categories.length > 0) {
                    // Fallback to first category if currentIndustry not set
                    currentIndustry = categories[0].category;
                    dataSelect.value = currentIndustry;
                    console.log('Initial industry set to:', currentIndustry);
                }
            } else {
                // Fallback options if categories not loaded
                dataSelect.innerHTML = `
                    <option value="">All Categories</option>
                    <option value="Gold Shops">Gold Shops</option>
                    <option value="Convenience Stores">Convenience Stores</option>
                    <option value="Department Stores">Department Stores</option>
                    <option value="Fast Fashion">Fast Fashion</option>
                `;
                if (currentIndustry) {
                    dataSelect.value = currentIndustry;
                } else {
                    currentIndustry = 'Gold Shops';
                    dataSelect.value = currentIndustry;
                }
            }
            
            // Add event listener for data selection dropdown
            dataSelect.addEventListener('change', (e) => {
                currentIndustry = e.target.value || '';
                console.log('Data selection changed to:', currentIndustry || 'All Categories');
                applyIndustryFilter();
                updateMapMarkers();
                updateStats();
                updateFloatingLegend();
                
                // Recalculate MPI with filtered data
                calculateMarketPowerIndex(visibleLocations);
                
                // Update MPI tab if it's active
                const mpiTab = document.querySelector('.tab-panel#mpi');
                if (mpiTab && mpiTab.classList.contains('active')) {
                    loadMPI(mpiTab);
                }
                
                // Enforce layer order after category change
                setTimeout(() => maintainLayerOrder(), 100);
            });

            // Setup radio-like behavior for markers and clusters
            const markersToggle = document.getElementById('markers-toggle');
            const clusterToggle = document.getElementById('cluster-toggle');
            
            // Markers toggle handler
            markersToggle.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                
                if (isChecked) {
                    // If markers is checked, uncheck clusters (radio behavior)
                    clusterToggle.checked = false;
                    updateStoreDisplayState(true, false);
                } else {
                    // If markers is unchecked, just update state
                    updateStoreDisplayState(false, clustersVisible);
                }
                
                // Enforce layer order after toggle
                setTimeout(() => maintainLayerOrder(), 100);
            });
            
            // Clusters toggle handler
            clusterToggle.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                
                if (isChecked) {
                    // If clusters is checked, uncheck markers (radio behavior)
                    markersToggle.checked = false;
                    updateStoreDisplayState(false, true);
                } else {
                    // If clusters is unchecked, just update state
                    updateStoreDisplayState(markersVisible, false);
                }
                
                // Enforce layer order after toggle
                setTimeout(() => maintainLayerOrder(), 100);
            });
            
            // DC toggle handler
            const dcToggle = document.getElementById('dc-toggle');
            if (dcToggle) {
                dcToggle.addEventListener('change', (e) => {
                    const showDC = e.target.checked;
                    console.log('DC toggle changed to:', showDC);
                    
                    // Update 99 SpeedMart DC markers visibility
                    if (map.getLayer('speedmart-distribution-centers-layer')) {
                        map.setLayoutProperty('speedmart-distribution-centers-layer', 'visibility', showDC ? 'visible' : 'none');
                    }
                    
                    // Update 99 SpeedMart DC connections visibility
                    if (map.getLayer('speedmart-dc-connections-layer')) {
                        map.setLayoutProperty('speedmart-dc-connections-layer', 'visibility', showDC ? 'visible' : 'none');
                    }
                    
                    // Update MR DIY DC markers visibility
                    if (map.getLayer('mrdiy-distribution-centers-layer')) {
                        map.setLayoutProperty('mrdiy-distribution-centers-layer', 'visibility', showDC ? 'visible' : 'none');
                    }
                    
                    // Update MR DIY DC connections visibility
                    if (map.getLayer('mrdiy-dc-connections-layer')) {
                        map.setLayoutProperty('mrdiy-dc-connections-layer', 'visibility', showDC ? 'visible' : 'none');
                    }
                    
                    // Update Oriental Kopi DC markers visibility
                    if (map.getLayer('orientalkopi-distribution-centers-layer')) {
                        map.setLayoutProperty('orientalkopi-distribution-centers-layer', 'visibility', showDC ? 'visible' : 'none');
                    }
                    
                    // Update Oriental Kopi DC connections visibility
                    if (map.getLayer('orientalkopi-dc-connections-layer')) {
                        map.setLayoutProperty('orientalkopi-dc-connections-layer', 'visibility', showDC ? 'visible' : 'none');
                    }
                    
                    // Update statistics panel visibility
                    const dcStatsPanel = document.getElementById('dc-statistics');
                    if (dcStatsPanel) {
                        dcStatsPanel.style.display = showDC ? 'block' : 'none';
                    }
                    
                    // Enforce layer order after DC toggle
                    setTimeout(() => maintainLayerOrder(), 100);
                });
            }

            // Industry selector dropdown (now in analytics panel)
            // The dropdown will be created when analytics tab is loaded
        });
    </script>
    <script>
        // Backup: Also setup sidebar minimize button when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(function() {
                    if (typeof setupSidebarMinimize === 'function') {
                        setupSidebarMinimize();
                    }
                }, 300);
            });
        } else {
            setTimeout(function() {
                if (typeof setupSidebarMinimize === 'function') {
                    setupSidebarMinimize();
                }
            }, 300);
        }
    </script>
</body>
</html>
